#!/usr/bin/python
import os, sys, subprocess
import time
import re
import configparser
import logging
from pathlib import Path
from PIL import Image
from clckwrkbdgr import xdg, utils

"""
Each section in ini-file is a separate LED.

[Scroll Lock]
# Name from `xset q`...
name = "Scroll Lock"
# ...or name of command. Command should return 0 if 'on' and non-zero if 'off'.
# If both command and name is specified, command will be used.
command = "pidgin_has_unread"
# To display in hint message and in terminal:
character_on = 'S'
character_off = ' '
"""

def read_xset_led_status():
	if time.time() - read_xset_led_status.last_timestamp < 0.9:
		return read_xset_led_status.data
	xset = subprocess.Popen(["xset", "q"], stdout=subprocess.PIPE)
	out, err = xset.communicate()
	if xset.returncode != 0:
		if err:
			logging.error('failed to read xset state: {0}'.format(err))

	out = out.decode('utf-8')
	out = out.splitlines()[3:8]
	leds = {}
	for line in out:
		for status in re.findall(r'[0-9][0-9]: [A-Za-z 0-9]+: +o[fn][f ]', line):
			m = re.match(r'(\d+) *: *([^ ][^:]+) *: *(\w+)', status)
			if m and len(m.groups()) == 3:
				leds[m.groups()[1]] = m.groups()[2] == 'on'
	read_xset_led_status.data = leds
	read_xset_led_status.last_timestamp = time.time()
	return leds
read_xset_led_status.data = {}
read_xset_led_status.last_timestamp = 0

class Plugin(object):
	def __init__(self, led_list_callback, state_symbol, character_on, character_off, image_on, image_off, command=None, name=None, title=None):
		self.state = False

		self.led_list_callback = led_list_callback
		self.state_symbol = state_symbol
		self.command = command
		self.title = title
		self.name = name
		self.character_on = character_on
		self.character_off = character_off
		self.image_on = os.path.expanduser(image_on)
		self.image_off = os.path.expanduser(image_off)
	def get_character(self, is_on):
		return self.character_on if is_on else self.character_off
	def get_image(self, is_on):
		return self.image_on if is_on else self.image_off
	def update_state(self):
		new_state = False
		if self.command:
			try:
				new_state = 0 == subprocess.call(self.command, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
			except FileNotFoundError:
				logging.error("Error executing command {0}".format(repr(self.command)))
		elif self.name:
			reverse_state = False
			name = self.name
			if name.startswith('!'):
				name = name[1:]
				reverse_state = True

			xset = read_xset_led_status()
			if name in xset:
				new_state = xset[name]
				if reverse_state:
					new_state = not new_state
			else:
				logging.error("Unknown led {0}".format(self.name))
		if self.state != new_state:
			self.state = new_state
			self.led_list_callback(self, self.state)

class Config(object):
	def __init__(self, filenames):
		self.filenames = filenames
		self.parser = configparser.ConfigParser()
		self.parser.read(list(map(str, self.filenames)))
	def _read_value(self, category, setting_name, default_value=None):
		value = category.get(setting_name)
		if value is None:
			logging.error("Missing setting {1} for group {0}.".format(repr(name), repr(setting_name)))
			return default_value
		return utils.unquote_string(value, fix_unicode_escape=True)
	def load_plugins(self, led_list_callback):
		for index, title in enumerate(self.parser):
			if title == 'DEFAULT':
				continue
			state_symbol = chr(ord('A') + index)
			group = self.parser[title]
			command, name = None, None
			if 'command' in group:
				command = utils.unquote_string(group['command'], fix_unicode_escape=True)
			elif 'name' in group:
				name = utils.unquote_string(group['name'], fix_unicode_escape=True)
			else:
				logging.error("Unknown group {0}. Where's command or name?".format(group))
				continue
			group = Plugin(led_list_callback, state_symbol,
					character_on=self._read_value(group, 'character_on', default_value=' '),
					character_off=self._read_value(group, 'character_off', default_value=' '),
					image_on=self._read_value(group, 'image_on'),
					image_off=self._read_value(group, 'image_off'),
					command=command, name=name, title=title,
					)
			yield group

def join_image_strip(image_files, output_file):
	""" Join multiple image files into a single horizontal strip. """
	if not image_files:
		empty_transparent_pixel = Image.new('RGBA', (1, 1), (0, 0, 0, 0))
		empty_transparent_pixel .save(str(output_file))
		return
	frames = [Image.open(str(image)) for image in image_files if image]
	widths = [image.width for image in frames]
	full_width, frame_width = sum(widths), max(widths)
	full_height = max([image.width for image in frames])
	band = Image.new('RGBA', (full_width, full_height))
	for index, frame in enumerate(frames):
		band.paste(frame, (frame_width * index, 0))
	band.save(str(output_file))

class GenMon:
	IMAGE_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.png"
	TOOLTIP_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.txt"

	def __init__(self, genmon_id):
		self.genmon_id = genmon_id
	def update(self, plugins):
		tooltip = []
		images = []
		for group in plugins:
			tooltip.append(group.title)
			images.append(group.get_image(True))
		tooltip = '\n'.join(tooltip)
		join_image_strip(images, GenMon.IMAGE_PATH)
		GenMon.TOOLTIP_PATH.write_text(tooltip)
	def refresh_plugin(self):
		# FIXME works only with xfce4-plugin-genmon >= 4.0.2, but there is no way to get current version of a plugin.
		# FIXME otherwise need to set genmon to refresh rate = 1s
		subprocess.call(['xfce4-panel', '--plugin-event={0}:refresh:bool:true'.format(self.genmon_id)])

	@staticmethod
	def get_text():
		GenMon.IMAGE_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.png"
		GenMon.TOOLTIP_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.txt"
		return "<img>{0}</img>\n<tool>{1}</tool>\n".format(GenMon.IMAGE_PATH, GenMon.TOOLTIP_PATH.read_text())

class LEDList:
	def __init__(self):
		self.items = []
		self.changed = False
	def set(self, item):
		self.items.append(item)
		self.changed = True
	def unset(self, item):
		try:
			self.items.remove(item)
			self.changed = True
		except ValueError:
			pass
	def get(self):
		self.changed = False
		return self.items
	def callback(self, plugin, state):
		if state:
			self.set(plugin)
		else:
			self.unset(plugin)

import click

@click.command()
def cli():
	""" Serves as daemon, updating led info when state is changes.
	Use $XDG_CONFIG_HOME/bin/xfce-leds-genmon.sh to turn this info into output suitable for genmon plugin.
	"""
	settings = Config([
		xdg.save_config_path('xfce4')/"xfce-leds.ini",
		Path('~/.local').expanduser()/"xfce-leds.ini", # TODO use XDG.
		])
	leds = LEDList()
	plugins = list(settings.load_plugins(leds.callback))
	genmon = GenMon('genmon-2')
	while True:
		for plugin in plugins:
			plugin.update_state()
		if leds.changed:
			genmon.update(leds.get())
			genmon.refresh_plugin()
		time.sleep(1)

if __name__ == "__main__":
	cli()
