#!/usr/bin/python
import os, sys, subprocess
import re
import configparser
import logging
from PIL import Image
from clckwrkbdgr import xdg, utils

"""
Each section in ini-file is a separate LED.

[Scroll Lock]
# Name from `xset q`...
name = "Scroll Lock"
# ...or name of command. Command should return 0 if 'on' and non-zero if 'off'.
# If both command and name is specified, command will be used.
command = "pidgin_has_unread"
# To display in hint message and in terminal:
character_on = 'S'
character_off = ' '
"""

STATE_IMAGE_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.png"
STATE_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state"
STATE_TOOLTIP_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.txt"

def read_xset_led_status():
	xset = subprocess.Popen(["xset", "q"], stdout=subprocess.PIPE)
	out, err = xset.communicate()
	if xset.returncode != 0:
		if err:
			logging.error('failed to read xset state: {0}'.format(err))

	out = out.decode('utf-8')
	out = out.splitlines()[3:8]
	leds = {}
	for line in out:
		for status in re.findall(r'[0-9][0-9]: [A-Za-z 0-9]+: +o[fn][f ]', line):
			m = re.match(r'(\d+) *: *([^ ][^:]+) *: *(\w+)', status)
			if m and len(m.groups()) == 3:
				leds[m.groups()[1]] = m.groups()[2] == 'on'
	return leds

class Config(object):
	class Group(object):
		def __init__(self, state_symbol, character_on, character_off, image_on, image_off, command=None, name=None, title=None):
			self.state_symbol = state_symbol
			self.command = command
			self.title = title
			self.name = name
			self.character_on = character_on
			self.character_off = character_off
			self.image_on = os.path.expanduser(image_on)
			self.image_off = os.path.expanduser(image_off)
		def get_character(self, is_on):
			return self.character_on if is_on else self.character_off
		def get_image(self, is_on):
			return self.image_on if is_on else self.image_off

	def __init__(self, filename):
		self.filename = filename
		self.parser = configparser.ConfigParser()
		self.parser.read([str(self.filename)])
	def last_update(self):
		return os.path.getmtime(str(self.filename))
	def _read_value(self, category, setting_name, default_value=None):
		value = category.get(setting_name)
		if value is None:
			logging.error("Missing setting {1} for group {0}.".format(repr(name), repr(setting_name)))
			return default_value
		return utils.unquote_string(value, fix_unicode_escape=True)
	def all_groups(self):
		for index, title in enumerate(self.parser):
			if title == 'DEFAULT':
				continue
			state_symbol = chr(ord('A') + index)
			group = self.parser[title]
			command, name = None, None
			if 'command' in group:
				command = utils.unquote_string(group['command'], fix_unicode_escape=True)
			elif 'name' in group:
				name = utils.unquote_string(group['name'], fix_unicode_escape=True)
			else:
				logging.error("Unknown group {0}. Where's command or name?".format(group))
				continue
			group = Config.Group(state_symbol,
					character_on=self._read_value(group, 'character_on', default_value=' '),
					character_off=self._read_value(group, 'character_off', default_value=' '),
					image_on=self._read_value(group, 'image_on'),
					image_off=self._read_value(group, 'image_off'),
					command=command, name=name, title=title,
					)
			yield group

def join_image_strip(image_files, output_file):
	""" Join multiple image files into a single horizontal strip. """
	frames = [Image.open(str(image)) for image in image_files if image]
	widths = [image.width for image in frames]
	full_width, frame_width = sum(widths), max(widths)
	full_height = max([image.width for image in frames])
	band = Image.new('RGBA', (full_width, full_height))
	for index, frame in enumerate(frames):
		band.paste(frame, (frame_width * index, 0))
	band.save(str(output_file))

def get_genmon_text():
	STATE_IMAGE_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.png"
	STATE_TOOLTIP_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.txt"
	return "<img>{0}</img>\n<tool>{1}</tool>\n".format(STATE_IMAGE_PATH, STATE_TOOLTIP_PATH.read_text())

def recalculate_state(settings):
	tooltip = []
	images = []
	states = ''
	leds = read_xset_led_status()
	for group in settings.all_groups():
		state = False
		if group.command:
			try:
				state = 0 == subprocess.call(group.command, shell=True)
			except FileNotFoundError:
				logging.error("Error executing command {0}".format(repr(group.command)))
		elif group.name:
			if group.name in leds:
				state = leds[group.name]
			else:
				logging.error("Unknown led {0}".format(group.name))

		if state:
			tooltip.append(group.title)
		images.append(group.get_image(state))
		states += group.state_symbol.upper() if state else group.state_symbol.lower()
	return '\n'.join(tooltip), images, states

def update_files(tooltip, images, states):
	""" Returns True if state is changed. """
	if STATE_PATH.exists() and STATE_PATH.read_text() == states:
		return False
	join_image_strip(images, STATE_IMAGE_PATH)
	STATE_PATH.write_text(states)
	STATE_TOOLTIP_PATH.write_text(tooltip)
	return True

def refresh_genmon_plugin(genmon_id):
	subprocess.call(['xfce4-panel', '--plugin-event={0}:refresh:bool:true'.format(genmon_id)])

import click

@click.command()
def cli():
	""" Serves as daemon, updating led info when state is changes.
	Use $XDG_CONFIG_HOME/bin/xfce-leds-genmon.sh to turn this info into output suitable for genmon plugin.
	"""
	config_file = xdg.save_config_path('xfce4')/"xfce-leds.ini"
	settings = Config(config_file)
	while True:
		tooltip, images, states = recalculate_state(settings)
		if update_files(tooltip, images, states):
			# FIXME works only with xfce4-plugin-genmon >= 4.0.2, but there is no way to get current version of a plugin.
			# FIXME otherwise need to set genmon to refresh rate = 1s
			refresh_genmon_plugin('genmon-2')

if __name__ == "__main__":
	cli()
