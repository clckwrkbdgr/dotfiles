#!/usr/bin/python
import os, sys, subprocess
import time, threading, functools
import re
import configparser
import logging
from pathlib import Path
from PIL import Image
from clckwrkbdgr import xdg, utils

"""
Each section in ini-file is a separate LED.

[Scroll Lock]
# Name from `xset q`...
name = "Scroll Lock"
# ...or name of command. Command should return 0 if 'on' and non-zero if 'off'.
# If both command and name is specified, command will be used.
command = "pidgin_has_unread"
"""

def synchronized(f):
	lock = threading.RLock()
	@functools.wraps(f)
	def _actual(*args, **kwargs):
		with lock:
			return f(*args, **kwargs)
	return _actual

@synchronized
def read_xset_led_status():
	if time.time() - read_xset_led_status.last_timestamp < 0.9:
		return read_xset_led_status.data
	xset = subprocess.Popen(["xset", "q"], stdout=subprocess.PIPE)
	out, err = xset.communicate()
	if xset.returncode != 0:
		if err:
			logging.error('failed to read xset state: {0}'.format(err))

	out = out.decode('utf-8')
	out = out.splitlines()[3:8]
	leds = {}
	for line in out:
		for status in re.findall(r'[0-9][0-9]: [A-Za-z 0-9]+: +o[fn][f ]', line):
			m = re.match(r'(\d+) *: *([^ ][^:]+) *: *(\w+)', status)
			if m and len(m.groups()) == 3:
				leds[m.groups()[1]] = m.groups()[2] == 'on'
	read_xset_led_status.data = leds
	read_xset_led_status.last_timestamp = time.time()
	return leds
read_xset_led_status.data = {}
read_xset_led_status.last_timestamp = 0

# Plugin is a function that runs in a stand-alone thread and accepts arguments:
# - Plugin const data (string), from configuration.
# - Callback to update state: update_state(bool).
#   Should be called when state is changed.
# - Terminator object (threading.Event).
#   Plugin function should check value of the event and stop as soon as it .is_set()

def builtin_plugin_command(command, update_state, terminator):
	state = False
	while not terminator.is_set():
		try:
			new_state = 0 == subprocess.call(command, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
			if state != new_state:
				state = new_state
				update_state(state)
		except FileNotFoundError:
			logging.error("Error executing command {0}".format(repr(command)))
		time.sleep(1)

def builtin_plugin_led(led_name, update_state, terminator):
	state = False
	while not terminator.is_set():
		xset = read_xset_led_status()
		if led_name in xset:
			new_state = xset[led_name]
			if state != new_state:
				state = new_state
				update_state(state)
		else:
			logging.error("Unknown led {0}".format(led_name))
		time.sleep(1)

def builtin_plugin_led_off(led_name, update_state, terminator):
	state = False
	while not terminator.is_set():
		xset = read_xset_led_status()
		if led_name in xset:
			new_state = not xset[led_name]
			if state != new_state:
				state = new_state
				update_state(state)
		else:
			logging.error("Unknown led {0}".format(led_name))
		time.sleep(1)

class Plugin(object):
	def __init__(self, led_list_callback, image, title=None, plugin_func=None, data=None):
		self.led_list_callback = led_list_callback
		self.title = title
		self.image = image
		self.data = data
		self.plugin_func = plugin_func

	def run_thread(self, terminator):
		self.plugin_func(self.data,
				lambda state: self.led_list_callback(self, state),
				terminator
				)

class Config(object):
	def __init__(self, filenames):
		self.filenames = filenames
		self.parser = configparser.ConfigParser()
		self.parser.read(list(map(str, self.filenames)))
	def _read_value(self, category, setting_name, default_value=None):
		value = category.get(setting_name)
		if value is None:
			if default_value is None:
				logging.error("Missing setting {1} for group {0}.".format(repr(category), repr(setting_name)))
			return default_value
		return utils.unquote_string(value, fix_unicode_escape=True)
	def parse_plugin_function(self, group):
		plugin_func = self._read_value(group, 'plugin_func')
		plugin_data = self._read_value(group, 'plugin_data', '')
		if plugin_func:
			# TODO parse plugin func definition.
			return plugin_func, plugin_data
		# Legacy way of setting built-in plugins (TODO some deprecated warning).
		command, name = None, None
		if 'command' in group:
			command = utils.unquote_string(group['command'], fix_unicode_escape=True)
			return builtin_plugin_command, command
		elif 'name' in group:
			name = utils.unquote_string(group['name'], fix_unicode_escape=True)
			if name.startswith('!'):
				return builtin_plugin_led_off, name[1:]
			else:
				return builtin_plugin_led, name
		logging.error("Unknown group {0}. Where's command or name?".format(group))
		return None, None
	def load_plugins(self, led_list_callback):
		for index, title in enumerate(self.parser):
			if title == 'DEFAULT':
				continue
			group = self.parser[title]
			plugin_func, plugin_data = self.parse_plugin_function(group)
			image = self._read_value(group, 'image')
			if not image:
				# TODO deprecated warning.
				image = self._read_value(group, 'image_on')
			group = Plugin(led_list_callback,
					image=os.path.expanduser(image),
					plugin_func=plugin_func, data=plugin_data,
					title=title,
					)
			yield group

def join_image_strip(image_files, output_file):
	""" Join multiple image files into a single horizontal strip. """
	if not image_files:
		empty_transparent_pixel = Image.new('RGBA', (1, 1), (0, 0, 0, 0))
		empty_transparent_pixel .save(str(output_file))
		return
	frames = [Image.open(str(image)) for image in image_files if image]
	widths = [image.width for image in frames]
	full_width, frame_width = sum(widths), max(widths)
	full_height = max([image.width for image in frames])
	band = Image.new('RGBA', (full_width, full_height))
	for index, frame in enumerate(frames):
		band.paste(frame, (frame_width * index, 0))
	band.save(str(output_file))

class GenMon:
	IMAGE_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.png"
	TOOLTIP_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.txt"

	def __init__(self, genmon_id):
		self.genmon_id = genmon_id
	def update(self, plugins):
		tooltip = []
		images = []
		for group in plugins:
			tooltip.append(group.title)
			images.append(group.image)
		tooltip = '\n'.join(tooltip)
		join_image_strip(images, GenMon.IMAGE_PATH)
		GenMon.TOOLTIP_PATH.write_text(tooltip)
	def refresh_plugin(self):
		# FIXME works only with xfce4-plugin-genmon >= 4.0.2, but there is no way to get current version of a plugin.
		# FIXME otherwise need to set genmon to refresh rate = 1s
		subprocess.call(['xfce4-panel', '--plugin-event={0}:refresh:bool:true'.format(self.genmon_id)])

	@staticmethod
	def get_text():
		GenMon.IMAGE_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.png"
		GenMon.TOOLTIP_PATH = xdg.save_runtime_path('xfce4', 'leds')/"state.txt"
		return "<img>{0}</img>\n<tool>{1}</tool>\n".format(GenMon.IMAGE_PATH, GenMon.TOOLTIP_PATH.read_text())

class LEDList:
	def __init__(self):
		self.items = []
		self.changed = threading.Event()
		self.lock = threading.Lock()
	def set(self, item):
		with self.lock:
			self.items.append(item)
			self.changed.set()
	def unset(self, item):
		with self.lock:
			try:
				self.items.remove(item)
				self.changed.set()
			except ValueError:
				pass
	def get(self):
		return self.items
	def callback(self, plugin, state):
		if state:
			self.set(plugin)
		else:
			self.unset(plugin)

import click

@click.command()
def cli():
	""" Serves as daemon, updating led info when state is changes.
	Use $XDG_CONFIG_HOME/bin/xfce-leds-genmon.sh to turn this info into output suitable for genmon plugin.
	"""
	settings = Config([
		xdg.save_config_path('xfce4')/"xfce-leds.ini",
		Path('~/.local').expanduser()/"xfce-leds.ini", # TODO use XDG.
		])
	leds = LEDList()
	plugins = list(settings.load_plugins(leds.callback))
	genmon = GenMon('genmon-2')
	terminator = threading.Event()
	watchers = [threading.Thread(target=plugin.run_thread, args=(terminator,)) for plugin in plugins]
	try:
		for watcher in watchers:
			watcher.start()
		while True:
			leds.changed.wait()
			with leds.lock:
				genmon.update(leds.get())
				genmon.refresh_plugin()
				leds.changed.clear()
	finally:
		terminator.set()
		for watcher in watchers:
			watcher.join()

if __name__ == "__main__":
	cli()
