#!/usr/bin/python3
import os, sys, subprocess
import re
import configparser
import logging
import click
from PIL import Image
from clckwrkbdgr import xdg, utils

"""
Each section in ini-file is a separate LED.

[Scroll Lock]
# Name from `xset q`...
name = "Scroll Lock"
# ...or name of command. Command should return 0 if 'on' and non-zero if 'off'.
# If both command and name is specified, command will be used.
command = "pidgin_has_unread"
# To display in hint message and in terminal:
character_on = 'S'
character_off = ' '
"""

def read_xset_led_status():
	xset = subprocess.Popen(["xset", "q"], stdout=subprocess.PIPE)
	out, err = xset.communicate()
	if xset.returncode != 0:
		if err:
			logging.error('failed to read xset state: {0}'.format(err))

	out = out.decode('utf-8')
	out = out.splitlines()[3:8]
	leds = {}
	for line in out:
		for status in re.findall(r'[0-9][0-9]: [A-Za-z 0-9]+: +o[fn][f ]', line):
			m = re.match(r'(\d+) *: *([^ ][^:]+) *: *(\w+)', status)
			if m and len(m.groups()) == 3:
				leds[m.groups()[1]] = m.groups()[2] == 'on'
	return leds

class Config(object):
	class Group(object):
		def __init__(self, state_symbol, character_on, character_off, image_on, image_off, command=None, name=None):
			self.state_symbol = state_symbol
			self.command = command
			self.name = name
			self.character_on = character_on
			self.character_off = character_off
			self.image_on = os.path.expanduser(image_on)
			self.image_off = os.path.expanduser(image_off)
		def get_character(self, is_on):
			return self.character_on if is_on else self.character_off
		def get_image(self, is_on):
			return self.image_on if is_on else self.image_off

	def __init__(self, filename):
		self.filename = filename
		self.parser = configparser.ConfigParser()
		self.parser.read([str(self.filename)])
	def last_update(self):
		return os.path.getmtime(str(self.filename))
	def _read_value(self, category, setting_name, default_value=None):
		value = category.get(setting_name)
		if value is None:
			logging.error("Missing setting {1} for group {0}.\n".format(repr(name), repr(setting_name)))
			return default_value
		return utils.unquote_string(value, fix_unicode_escape=True)
	def all_groups(self):
		for index, name in enumerate(self.parser):
			if name == 'DEFAULT':
				continue
			state_symbol = chr(ord('A') + index)
			group = self.parser[name]
			command, name = None, None
			if 'command' in group:
				command = utils.unquote_string(group['command'], fix_unicode_escape=True)
			elif 'name' in group:
				name = utils.unquote_string(group['name'], fix_unicode_escape=True)
			else:
				logging.error("Unknown group {0}. Where's command or name?\n".format(group))
				continue
			group = Config.Group(state_symbol,
					character_on=self._read_value(group, 'character_on', default_value=' '),
					character_off=self._read_value(group, 'character_off', default_value=' '),
					image_on=self._read_value(group, 'image_on'),
					image_off=self._read_value(group, 'image_off'),
					command=command, name=name,
					)
			yield group

@click.command()
def cli():
	leds = read_xset_led_status()

	config_file = xdg.save_config_path('xfce4')/"xfce-leds.ini"
	settings = Config(config_file)
	tooltip = ''
	images = []
	states = ''
	for group in settings.all_groups():
		state = False
		if group.command:
			try:
				state = 0 == subprocess.call(group.command, shell=True)
			except FileNotFoundError:
				logging.error("Error executing command {0}\n".format(repr(group.command)))
		elif group.name:
			if group.name in leds:
				state = leds[group.name]
			else:
				logging.error("Unknown led {0}\n".format(group.name))

		tooltip += group.get_character(state)
		images.append(group.get_image(state))
		states += group.state_symbol.upper() if state else group.state_symbol.lower()
	state_image_path = xdg.save_cache_path('xfce4', 'leds')/"leds_{0}.png".format(states)
	image_exists = state_image_path.exists()
	image_is_too_old = image_exists and settings.last_update() > os.path.getmtime(str(state_image_path))
	if image_is_too_old:
		logging.error("Image is too old.\n")
	if not image_exists or image_is_too_old:
		frames = [Image.open(image) for image in images if image]
		widths = [image.width for image in frames]
		full_width, frame_width = sum(widths), max(widths)
		full_height = max([image.width for image in frames])
		band = Image.new('RGBA', (full_width, full_height))
		for index, frame in enumerate(frames):
			band.paste(frame, (frame_width * index, 0))
		band.save(str(state_image_path))
	sys.stdout.write("<img>{0}</img>\n<tool>{1}</tool>\n".format(state_image_path, tooltip))

if __name__ == "__main__":
	cli()
