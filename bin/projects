#!/bin/bash
tag() {
	SECTION="$1"
	LAST_VERSION=$(git tag | sed 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\)/\1/' | sort -nt . | tail -1)
	REPO_NAME=$(git remote -v | grep '(push)' | sed 's/.*\/\([^\/]*\)\.git.*/\1/')
	MAJOR=$(echo $LAST_VERSION | sed 's/.*\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)/\1/')
	MINOR=$(echo $LAST_VERSION | sed 's/.*\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)/\2/')
	REVISION=$(echo $LAST_VERSION | sed 's/.*\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)/\3/')
	MINOR=${MINOR:-0}
	MAJOR=${MAJOR:-0}
	REVISION=${REVISION:-0}

	if [ -z "$1" ]; then
		git tag
		exit
	fi

	case "$SECTION" in
		( major ) MAJOR=$((MAJOR+1)); MINOR=0; REVISION=0 ;;
		( minor ) MINOR=$((MINOR+1)); REVISION=0 ;;
		( rev | revision ) REVISION=$((REVISION+1)) ;;
		( * ) FAILED=true; echo "Unknown section: <$SECTION>. Should be: major, minor or revision (rev)." ;;
	esac
	[ "$FAILED" == true ] && exit 1

	NEW_VERSION="${MAJOR}.${MINOR}.${REVISION}"
	git tag
	echo -n "Add <$NEW_VERSION>, (y)es?"
	read YES
	if [ "$YES" == "y" ]; then
		git tag -a "${NEW_VERSION}" -m "${REPO_NAME} v${NEW_VERSION}"
		#git tag -a "${REPO_NAME}-${NEW_VERSION}" -m "v${NEW_VERSION}"
		echo "Added new tag <$NEW_VERSION>"
	fi
}

version() {
	VERSION=$(git tag | tail -1 | sed 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\)/\1/')
	MAJOR_VERSION=$(git tag | tail -1 | sed 's/.*\([0-9]\+\)\.[0-9]\+\.[0-9]\+/\1/')
	if [ "$1" == "major" ]; then
		echo "$MAJOR_VERSION"
	else
		echo "$VERSION"
	fi
}

status() {
	for D in */; do
		pushd $D >/dev/null
		if git st | grep -v 'nothing to commit' | grep -v 'Your branch is up-to-date with' | grep -vq '#\? *On branch master'; then
			echo -e "\033[1;31m$D\033[0m"
			git -c color.status=always st #  | sed 's/^#/ /'
		fi
		popd >/dev/null
	done
}

COMMAND="$1"
shift
case "$COMMAND" in
	"tag") tag ;;
	"version") version ;;
	"status") status ;;
esac
