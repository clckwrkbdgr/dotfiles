#!/bin/bash
# Collection of dev project handling functions.

# Handles Semantic Versioning for projects.
# Usage:
#    tag {minor|major|rev}
#         Updates specified section of version number and adds new tag.
#    tag
#         Lists all tags for current project.
tag() {
	SECTION="$1"
	LAST_VERSION=$(git tag | sed 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\)/\1/' | sort -nt . | tail -1)
	REPO_NAME=$(git remote -v | grep '(push)' | sed 's/.*\/\([^\/]*\)\.git.*/\1/')
	MAJOR=$(echo $LAST_VERSION | sed 's/.*\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)/\1/')
	MINOR=$(echo $LAST_VERSION | sed 's/.*\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)/\2/')
	REVISION=$(echo $LAST_VERSION | sed 's/.*\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)/\3/')
	MINOR=${MINOR:-0}
	MAJOR=${MAJOR:-0}
	REVISION=${REVISION:-0}

	if [ -z "$1" ]; then
		git tag
		exit
	fi

	case "$SECTION" in
		( major ) MAJOR=$((MAJOR+1)); MINOR=0; REVISION=0 ;;
		( minor ) MINOR=$((MINOR+1)); REVISION=0 ;;
		( rev | revision ) REVISION=$((REVISION+1)) ;;
		( * ) FAILED=true; echo "Unknown section: <$SECTION>. Should be: major, minor or revision (rev)." ;;
	esac
	[ "$FAILED" == true ] && exit 1

	NEW_VERSION="${MAJOR}.${MINOR}.${REVISION}"
	git tag
	echo -n "Add <$NEW_VERSION>, (y)es?"
	read YES
	if [ "$YES" == "y" ]; then
		git tag -a "${NEW_VERSION}" -m "${REPO_NAME} v${NEW_VERSION}"
		echo "Added new tag <$NEW_VERSION>"
	fi
}

# Extracts current project version from the last tag.
version() {
	VERSION=$(git tag | tail -1 | sed 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\)/\1/')
	MAJOR_VERSION=$(git tag | tail -1 | sed 's/.*\([0-9]\+\)\.[0-9]\+\.[0-9]\+/\1/')
	if [ "$1" == "major" ]; then
		echo "$MAJOR_VERSION"
	else
		echo "$VERSION"
	fi
}

# Prints statuses for all projects in directory recursively.
# Skips up-to-date projects, prints only modifications or pending commits.
status() {
	find -L . -type d | while read D; do
		[ ! -d "$D/.git" ] && continue
		pushd $D >/dev/null
		if git st | grep -v 'nothing to commit' | grep -v 'Your branch is up-to-date with' | grep -vq '#\? *On branch master'; then
			echo -e "\033[1;31m$D\033[0m"
			git -c color.status=always st
		fi
		popd >/dev/null
	done
}

# Pushes pending commits to remote repositories for all sub-directories recursively.
push() {
	find -L . -type d | while read D; do
		[ ! -d "$D/.git" ] && continue
		pushd $D >/dev/null
		if git st | grep -q 'Your branch is ahead of'; then
			echo -e "\033[1;31m$D\033[0m"
			git push origin master --tags
		fi
		popd >/dev/null
	done
}

COMMAND="$1"
shift
case "$COMMAND" in
	"tag") tag "$@" ;;
	"version") version ;;
	"status") status ;;
	"push") push ;;
esac
