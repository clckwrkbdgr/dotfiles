#!/bin/bash
# Collection of dev project handling functions.

# Handles Semantic Versioning for projects.
# Usage:
#    tag {minor|major|rev}
#         Updates specified section of version number and adds new tag.
#    tag
#         Lists all tags for current project.
tag() {
	SECTION="$1"
	LAST_VERSION=$(git tag | sed 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\)/\1/' | sort -nt . | tail -1)
	REPO_NAME=$(git remote -v | grep '(push)' | sed 's/.*\/\([^\/]*\)\.git.*/\1/')
	MAJOR=$(echo $LAST_VERSION | sed 's/.*\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)/\1/')
	MINOR=$(echo $LAST_VERSION | sed 's/.*\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)/\2/')
	REVISION=$(echo $LAST_VERSION | sed 's/.*\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)/\3/')
	MINOR=${MINOR:-0}
	MAJOR=${MAJOR:-0}
	REVISION=${REVISION:-0}

	if [ -z "$1" ]; then
		git tag
		exit
	fi

	case "$SECTION" in
		( major ) MAJOR=$((MAJOR+1)); MINOR=0; REVISION=0 ;;
		( minor ) MINOR=$((MINOR+1)); REVISION=0 ;;
		( rev | revision ) REVISION=$((REVISION+1)) ;;
		( * ) FAILED=true; echo "Unknown section: <$SECTION>. Should be: major, minor or revision (rev)." ;;
	esac
	[ "$FAILED" == true ] && exit 1

	NEW_VERSION="${MAJOR}.${MINOR}.${REVISION}"
	git tag
	echo -n "Add <$NEW_VERSION>, (y)es?"
	read YES
	if [ "$YES" == "y" ]; then
		git tag -a "${NEW_VERSION}" -m "${REPO_NAME} v${NEW_VERSION}"
		echo "Added new tag <$NEW_VERSION>"
	fi
}

# Extracts current project version from the last tag.
version() {
	VERSION=$(git tag | tail -1 | sed 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\)/\1/')
	MAJOR_VERSION=$(git tag | tail -1 | sed 's/.*\([0-9]\+\)\.[0-9]\+\.[0-9]\+/\1/')
	if [ "$1" == "major" ]; then
		echo "$MAJOR_VERSION"
	else
		echo "$VERSION"
	fi
}

git_has_changes() {
	git st | \
		grep -v '#\? *On branch master' | \
		grep -v 'На ветке master' | \
		grep -v 'Your branch is up-to-date with' | \
		grep -v 'Ваша ветка обновлена в соответствии с ' | \
		grep -v 'nothing to commit' | \
		grep -v 'нечего коммитить, нет изменений в рабочем каталоге' | \
		grep -v '^$'
}

git_has_changes_besides_filtered_out() {
	git st | \
		grep -v '#\? *On branch master' | \
		grep -v 'На ветке master' | \
		grep -v 'Your branch is up-to-date with' | \
		grep -v 'Ваша ветка обновлена в соответствии с ' | \
		grep -v 'nothing to commit' | \
		grep -v 'нечего коммитить, нет изменений в рабочем каталоге' | \
		grep -v '(use "git add <file>..." to update what will be committed)' | \
		grep -v '(используйте «git add <файл>…», чтобы добавить файл в индекс)' | \
		grep -v '(use "git checkout -- <file>..." to discard changes in working directory)' | \
		grep -v '(используйте «git checkout -- <файл>…», чтобы отменить изменения' | \
		grep -v 'в рабочем каталоге)' | \
		grep -v 'no changes added to commit (use "git add"' | \
		grep -v 'нет изменений добавленных для коммита' | \
		grep -v '(используйте «git add» и/или «git commit -a»)' | \
		while read line; do
			if [ -z "$IN_CHANGES" ]; then
				if echo "$line" | grep -q '^Changes not staged for commit:'; then
					IN_CHANGES=1
				else
					echo "$line"
				fi
			else
				if echo "$line" | grep -v '^$' | grep -vq '^modified: '; then
					IN_CHANGES=0
					echo "$line"
				fi
				if echo "$line" | grep -q '^modified: '; then
					filename="$(echo "$line" | sed 's/^modified: *\(.*\)/\1/')"
					git diff "$filename"
				fi
			fi
		done | \
		grep -v '^$'
}

# Prints statuses for all projects in directory recursively.
# Skips up-to-date projects, prints only modifications or pending commits.
status() {
	HAS_CHANGES=git_has_changes
	if [ "$1" == "thorough" ]; then
		HAS_CHANGES=git_has_changes_besides_filtered_out
		shift
	fi
	find -L . -type d | while read D; do
		[ ! -d "$D/.git" ] && continue
		pushd $D >/dev/null
		if $HAS_CHANGES >/dev/null; then
			[ "$D" == "." ] && D="$(basename "$(pwd)")"
			echo -e "\033[1;31m$D\033[0m"
			git -c color.status=always st
		fi
		popd >/dev/null
	done
}

# Pushes pending commits to remote repositories for all sub-directories recursively.
push() {
	find -L . -type d | while read D; do
		[ ! -d "$D/.git" ] && continue
		pushd $D >/dev/null
		if git st | grep -q 'Your branch is ahead of'; then
			[ "$D" == "." ] && D="$(basename "$(pwd)")"
			echo -e "\033[1;31m$D\033[0m"
			git push origin master --tags
			git remote | grep -q local && git push local master --tags
		fi
		popd >/dev/null
	done
}

# Creates Git bare repository in local filesystem and adds it as a remote to current repo.
addlocal() {
	LOCAL_REMOTE_NAME='local'
	if git remote | grep -q "^${LOCAL_REMOTE_NAME}$"; then
		echo "Git remote named '$LOCAL_REMOTE_NAME' is already added to this repo:"
		git remote -v
		return 1
	fi
	REPO_STORAGE_PATH="${1}"
	if [ -z "$REPO_STORAGE_PATH" ]; then
		echo "Repo storage path is missing"
		echo "Usage: projects addlocal <repo local storage path>[/<repo name>[.git]]"
		return 1
	fi
	REPO_STORAGE_PATH="${REPO_STORAGE_PATH%%/}"
	if [ ! -e "$REPO_STORAGE_PATH" ]; then
		NAME="$(basename "$REPO_STORAGE_PATH")"
		NAME=${NAME%%.git}
		REPO_STORAGE_PATH="$(dirname "$REPO_STORAGE_PATH")"
	else
		ROOTDIR=$(git rev-parse --show-toplevel)
		NAME="$(basename "$ROOTDIR")"
	fi
	NEW_REMOTE_PATH="$REPO_STORAGE_PATH/${NAME}.git"
	if [ -e "$NEW_REMOTE_PATH" ]; then
		echo "Remote path '$1' already exists."
		return 1
	fi
	echo -n "Add new bare repo at $NEW_REMOTE_PATH? "
	read answer
	if [ "$answer" == "y" ]; then
		git init --bare "$NEW_REMOTE_PATH"
		git remote add "$LOCAL_REMOTE_NAME" "$NEW_REMOTE_PATH"
		git push "$LOCAL_REMOTE_NAME" master --tags
	fi
}

COMMAND="$1"
shift
case "$COMMAND" in
	"tag") tag "$@" ;;
	"version") version "$@" ;;
	"status") status "$@" ;;
	"push") push "$@" ;;
	"addlocal") addlocal "$@" ;;
esac
