#!/usr/bin/python
import os, sys, subprocess
import re
import logging
from collections import namedtuple
from termcolor import colored
from clckwrkbdgr import utils
import clckwrkbdgr.vcs.git as vcs
from clckwrkbdgr.fs import CurrentDir

LOCAL_REMOTE_NAME = 'local'

extract_match = lambda match: match.group(1) if match else None
non_empty = lambda x:x
print_lines = lambda lines: map(print, lines)

def match_any(line, patterns):
	return list(filter(non_empty, (re.match(expr, line) for expr in patterns)))

def search_any(line, patterns):
	return list(filter(non_empty, (re.search(expr, line) for expr in patterns)))

def skip_lines_with_patterns(lines, patterns):
	return [line for line in lines if not any(re.search(expr, line) for expr in patterns)]

def skip_lines_that_contains(lines, parts):
	return [line for line in lines if not any(part in line for part in parts)]

SemVer = namedtuple('SemVer', 'major minor revision')

class Git:
	class Error(RuntimeError): pass
	def add_tag(self, new_tag, commit_message):
		subprocess.run(["git", "tag", "-a", new_tag, "-m", commit_message])
	def push(self, remote='origin', branch='master'):
		subprocess.run(["git", "push", remote, branch, "--tags"])
	def add_bare_remote(self, name, path):
		existed = os.path.exists(path)
		if existed:
			print('Remote path already exists, considering bare repo already inited.')
		if not existed:
			subprocess.run(["git", "init", "--bare", path])
		subprocess.run(["git", "remote", "add", name, path])
		if not existed:
			subprocess.run(["git", "push", "-u", name, "master", "--tags"])
	def rootdir(self):
		git = subprocess.run(["git", "rev-parse", "--show-toplevel"], stdout=subprocess.PIPE)
		if git.returncode != 0:
			raise Git.Error(git.args)
		return git.stdout.decode().splitlines()[0]
	def tags(self):
		git = subprocess.run(["git", "tag"], stdout=subprocess.PIPE)
		if git.returncode != 0:
			raise Git.Error(git.args)
		return git.stdout.decode().splitlines()
	def remotes(self):
		git = subprocess.run(["git", "remote", "-v"], stdout=subprocess.PIPE)
		if git.returncode != 0:
			raise Git.Error(git.args)
		return git.stdout.decode().splitlines()
	def status(self, with_branch=False):
		args = ["git", "status", '--porcelain']
		if with_branch:
			args += ['--branch']
		git = subprocess.run(args, stdout=subprocess.PIPE)
		if git.returncode != 0:
			raise Git.Error(git.args)
		return git.stdout.decode().splitlines()
	def differs(self, filename):
		git = subprocess.run(["git", "diff", "--numstat", filename], stdout=subprocess.PIPE)
		if git.returncode != 0:
			raise Git.Error(git.args)
		diff = git.stdout.decode()
		if not diff:
			return False
		diff = diff .splitlines()[0]
		diff = diff.split(maxsplit=2)
		return diff[0] != '0' or diff[1] != '0'
	def branches(self):
		git = subprocess.run(["git", "branch"], stdout=subprocess.PIPE)
		if git.returncode != 0:
			raise Git.Error(git.args)
		return [line[2:] for line in git.stdout.decode().splitlines()]

import click

@click.group()
def cli():
	""" Collection of dev project handling functions. """
	pass

def versions_from_tags(tags):
	versions = [extract_match(re.search(r'(\d+[.]\d+[.]\d+)', line)) for line in tags]
	versions = filter(non_empty, versions)
	versions = map(lambda version: SemVer(*(map(int, version.split('.')))), versions)
	return sorted(versions)

def find_repo_name(remotes):
	repo_names = set([extract_match(re.search(r'/([^/]*)[.]git')) for remote in remotes if '(push)' in remote])
	if not repo_names:
		print("Cannot extract unambiguous repo name from `git remote -v`: no valid remotes")
		return None
	if len(repo_names) > 1:
		print("Cannot extract unambiguous repo name from `git remote -v`: {0}".format(', '.join(repo_names)))
		return None
	return next(iter(repo_names))

@cli.command()
@click.argument('section', required=False, default=None, type=click.Choice(['major', 'minor', 'rev', 'revision']))
@utils.exits_with_return_value
def tag(section=None):
	""" Handles Semantic Versioning for projects.
	Creates new tag with advancement in specified section of the version.
	If section is not specified, lists all tags for current project.
	"""
	tags = vcs.list_tags()
	if section is None:
		print_lines(tags)
		return True

	versions = versions_from_tags(tags)
	repo_name = vcs.get_repo_name(remote=True)

	last_version = versions[-1] if versions else SemVer(0, 0, 0)
	if section == 'major':
		new_version = SemVer(last_version.major + 1, 0, 0)
	elif section == 'minor':
		new_version = SemVer(last_version.major, last_version.minor + 1, 0)
	elif section in 'rev revision'.split():
		new_version = SemVer(last_version.major, last_version.minor, last_version.revision + 1)
	else:
		print("Unknown section: <{0}>. Should be: major, minor or revision (rev).".format(section))
		return False

	new_version = '.'.join(new_version)
	print_lines(tags)
	yes = input("Add <{0}>, (y)es? ".format(new_version))
	if yes.lower() != "y":
		return False
	vcs.create_tag(new_version, "{0} v{1}".format(repo_name, new_version))
	print("Added new tag <{0}>".format(new_version))
	return True

@cli.command()
@click.argument('section', required=False, default=None, type=click.Choice(['major', 'minor', 'rev', 'revision']))
@utils.exits_with_return_value
def version(section=None):
	""" Displays current project's version.
	Extracts current project version from the last tag.
	"""
	versions = versions_from_tags(vcs.list_tags())
	if not versions:
		return False
	version = versions[-1]
	if section == 'major':
		print(version.major)
	elif section == 'minor':
		print(version.minor)
	elif section in 'rev revision'.split():
		print(version.revision)
	elif section is None:
		print('.'.join(map(str, version)))
	else:
		print("Unknown section: <{0}>. Should be: major, minor or revision (rev).".format(section))
		return False
	return True

@cli.command()
@click.argument('thorough', required=False, default=None, type=click.Choice(['thorough']))
@click.option('--thorough', 'thorough_flag', is_flag=True, help='Checks actual diffs to see if gitfilters actually produce no diff.')
@utils.exits_with_return_value
def status(thorough=False, thorough_flag=False):
	""" Checks project's status.
	Prints statuses for all projects in directory recursively.
	Skips up-to-date projects, prints only modifications or pending commits.
	"""
	thorough = (thorough == 'thorough') or thorough_flag
	for repo in vcs.find_repos():
		with CurrentDir(repo):
			if vcs.has_changes(check_diff=thorough):
				print(colored(repo.name, 'red'))
				sys.stdout.flush()
				vcs.show_diff(with_color=True)
	return True

@cli.command()
@utils.exits_with_return_value
def push():
	""" Pushes pending commits to remote repositories for all sub-directories recursively. """
	for repo in vcs.find_repos():
		with CurrentDir(repo):
			if not vcs.branch_is_ahead_remote():
				continue
			print(colored(repo.name, 'red'))
			branches = vcs.list_branches()
			remotes = vcs.list_remotes()
			for branch in branches:
				for remote in remotes:
					vcs.push(remote, branch)
	return True

@cli.command()
@click.argument('repo_storage_path')
@utils.exits_with_return_value
def addlocal(repo_storage_path):
	""" Creates Git bare repository in local filesystem and adds it as a remote to current repo.
	REPO_STORAGE_PATH is <repo local storage path>[/<repo name>[.git]]
	"""
	remotes = vcs.list_remotes()
	if LOCAL_REMOTE_NAME in remotes:
		print("Git remote named '{0}' is already added to this repo:".format(LOCAL_REMOTE_NAME))
		print('\n'.join(remotes))
		return False
	if not os.path.exists(repo_storage_path):
		name = os.path.basename(repo_storage_path)
		if name.endswith('.git'):
			name = name[:-4]
		repo_storage_path = os.path.dirname(repo_storage_path)
	else:
		name = vcs.get_repo_name()
	new_remote_path = os.path.join(repo_storage_path, name + '.git')
	yes = input("Add new bare repo at {0}? ".format(new_remote_path))
	if yes.lower() != "y":
		return False
	vcs.add_local_remote(LOCAL_REMOTE_NAME, new_remote_path, bare=True)
	return True

@cli.command()
@utils.exits_with_return_value
def commit_submodules():
	""" Commits updated submodules if there are any. """
	with vcs.Stash(keep_index=True):
		need_commit = [sm_path for sm_path in vcs.list_submodules() if vcs.file_needs_commit(sm_path)]
		if not need_commit:
			return True
		return vcs.commit(need_commit, message='Updated submodules.')

if __name__ == "__main__":
	try:
		cli()
	except Git.Error as e:
		logging.error(e)
		sys.exit(1)
