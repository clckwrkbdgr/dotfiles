#!/usr/bin/env python
import os, sys, subprocess
import itertools
import configparser
try:
	from pathlib2 import Path
except ImportError: # pragma: no cover
	from pathlib import Path
try:
	import termcolor
except ImportError: # pragma: no cover
	import dummy as termcolor

class Registry(object):
	""" Registry of functions with optional set of attributes.
	Usage:
	registry = Registry('name', 'some_other_attr')
	@registry('foo', 'bar')
	def function(arbitrary_args...):
		...
	for func in registry:
		func(...)
		func.name
		func.some_other_attr
		....
	"""
	def __init__(self, *required_keywords):
		""" If required_keywords are specified,
		each decorator will expect a set of unnamed arguments of the same size.
		Keywords and arguments are matched correspondingly as attributes.
		See __call__ for details about attributes.
		"""
		self._list = []
		self._required_keywords = required_keywords or []
	def __iter__(self):
		""" Yields registered functions.
		Attributes are available as ordinary attributes of function objects:
		for func in registry:
			func.name
			func.some_other_attr
			...
		"""
		return iter(self._list)
	def __call__(self, *required_attrs, **attrs):
		""" Registers function with attributes.
		If some attributes are passed as unnamed arguments, they are matched with
		corresponding keyword from Registry definition.
		Attribute name should be proper Python keyword,
		as they will be available as ordinary attribute of function object.
		"""
		assert len(required_attrs) == len(self._required_keywords), 'Number of supplied unnamed arguments {0} does not correspond defined number of required keywords {1}'.format(repr(required_attrs), repr(self._required_keywords))
		attrs.update(dict(zip(self._required_keywords, required_attrs)))
		def _real_wrapper(func):
			for attr_name, attr_value in attrs.items():
				setattr(func, attr_name, attr_value)
			self._list.append(func)
			return func
		return _real_wrapper

test_suite = Registry('name')

#@test_suite('py2')
def python_2_unittest(test):
	rc = subprocess.call(['python2', '-m', 'coverage', 'run', '-m', 'unittest', test or 'discover'])
	rc += subprocess.call(['python2', '-m', 'coverage', 'report', '-m'])
	return rc

#@test_suite('py3')
def python_3_unittest(test):
	rc = subprocess.call(['python3', '-m', 'coverage', 'run', '-m', 'unittest', test or 'discover'])
	rc += subprocess.call(['python3', '-m', 'coverage', 'report', '-m'])
	return rc

@test_suite('bash')
def bash_unittest(test): # TODO merge all this into unittest.bash
	found = []
	for root, dirnames, filenames in os.walk('.'):
		root = Path(root)
		for filename in filenames:
			if not filename.endswith('.bash'):
				continue
			filename = root/filename
			module_name = '.'.join(filename.parts)
			assert module_name.endswith('.bash'), repr(module_name)
			module_name = module_name[:-5]
			if test and not test.startswith(module_name):
				continue
			# TODO call test_*.bash with some argument like '--list'
			# TODO to get actual list of test cases in the module
			lines = filename.read_text().splitlines()
			unittest_run = [line.startswith('unittest::run') for line in lines]
			if not unittest_run:
				continue
			prefixes = {(parts[1] if len(parts) > 1 else 'test_') for parts in map(str.split, lines)}
			test_cases = list(itertools.chain.from_iterable([line for line in lines if line.startswith(prefix)] for prefix in prefixes))
			if test and len(test) > len(module_name):
				# FIXME cannot run specific test yet.
				matching_cases = [case for case in test_cases if (module_name + '.' + case).startswith(test)]
				if not matching_cases:
					continue
			found.append(filename)
	rc = 0
	for filename in found:
		rc += subprocess.call(['bash', str(filename)])
	return rc

if __name__ == '__main__': # TODO click
	setup_cfg = configparser.SafeConfigParser()
	setup_cfg.read(['setup.cfg'])
	if 'unittest' in setup_cfg:
		if 'data_dir' in setup_cfg['unittest']:
			data_dir = setup_cfg['unittest']['data_dir']
			Path(data_dir).expanduser().mkdir(parents=True, exist_ok=True)

	tests = sys.argv[1:] or [None]
	rc = 0
	for runner in test_suite:
		for test in tests:
			print(termcolor.colored('Running {0} tests for: {1}'.format(runner.name, test or '<autodiscovery>'), 'blue'))
			result = runner(test)
			rc += result
			if result == 0:
				print(termcolor.colored('Success.', 'green'))
			else:
				print(termcolor.colored('RC: {0}'.format(result), 'red'))
	if rc != 0:
		print(termcolor.colored('Total RC: {0}'.format(rc), 'red'))
	sys.exit(rc)
