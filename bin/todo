#!/usr/bin/env python
import os, sys, re, subprocess
import logging
logger = logging.getLogger('todo')
import platform
import click, click_default_group
import json
import termcolor
from pathlib import Path
from clckwrkbdgr import utils, xdg
from clckwrkbdgr.collections import dotdict
import clckwrkbdgr.click
import clckwrkbdgr.todo
import clckwrkbdgr.todo.search
import clckwrkbdgr.todo.tasklist
import clckwrkbdgr.fs

def format_file_line(filename, line_number, value):
	""" Formats colored search result line:
	  <filename>:<line number>:<line>
	If line_number is 0 or None, treats value as error message and formats without line number:
	  <filename>:<message>
	"""
	result = termcolor.colored(str(filename), 'magenta') + termcolor.colored(':', 'cyan')
	if line_number:
		result += termcolor.colored(str(line_number), 'green') + termcolor.colored(':', 'cyan')
	if line_number:
		result += str(value)
	else:
		result += termcolor.colored(str(value), 'red')
	return result

def colored_matches(matches):
	""" Marks matched patterns found in string line with bold green color. """
	result = ''
	is_marker = False
	for m in matches:
		if is_marker:
			m = termcolor.colored(m, 'green', attrs=['bold'])
		result += m
		is_marker = not is_marker
	return result

def track_directory(dirpath):
	if not sys.stderr.isatty():
		return
	sys.stderr.write(str(dirpath))
	sys.stderr.write('\r')

@clckwrkbdgr.click.windows_noexpand_args
@click.group(cls=click_default_group.DefaultGroup, default='inbox', default_if_no_args=True, epilog=clckwrkbdgr.todo.CONFIG_FILE_DESC)
@click.option('--debug', is_flag=True, help='Enables debug output.')
def cli(debug=False):
	config = clckwrkbdgr.todo.read_config() # Pre-loading configuration.
	handler = logging.StreamHandler() # TODO custom formatter to display level, module, logger name etc.; and generic clckwrkbdgr module for such loggers.
	logger.addHandler(handler)
	if debug:
		logger.setLevel(logging.DEBUG)

@cli.command()
@click.argument('add_notes', nargs=-1)
@utils.exits_with_return_value
def inbox(add_notes=None):
	config = clckwrkbdgr.todo.read_config()
	config.inbox_file.parent.mkdir(parents=True, exist_ok=True)
	if add_notes:
		new_data = ' '.join(add_notes) + '\n'
		if config.prepend_inbox:
			with config.inbox_file.open('r+') as f:
				old_data = f.read()
				f.seek(0)
				f.write(new_data + old_data)
		else:
			with config.inbox_file.open('a+') as f:
				f.write(new_data)
		return True
	filename = str(config.inbox_file)
	if platform.system() == 'Windows':
		# On win32 if vim starts with single file and it contains backslashes,
		# Vim changes CWD to the base dir of the file.
		# To prevent this, slashes should be forward: C:/path/to/file
		filename = filename.replace('\\', '/')
	return 0 == subprocess.call(config.editor + [filename], shell=(platform.system() == 'Windows'))

@cli.command('sync')
@utils.exits_with_return_value
def sync_tasks():
	config = clckwrkbdgr.todo.read_config()
	tasklist_class = config.tasklist or clckwrkbdgr.todo.tasklist.TaskList
	tasklist = tasklist_class()
	ok = tasklist.sync()
	return ok

@cli.command('list')
@click.option('-v', '--verbose', is_flag=True, help='Display priority legend for each task.')
@utils.exits_with_return_value
def list_tasks(verbose=False):
	config = clckwrkbdgr.todo.read_config()
	tasklist_class = config.tasklist or clckwrkbdgr.todo.tasklist.TaskList
	tasklist = tasklist_class()
	prefixes = ('+', '|', '|')
	for item in tasklist.list_all(with_groups=True):
		if utils.is_collection(item):
			for index, subtask in enumerate(item):
				prefix = prefixes[0] if index == 0 else (prefixes[2] if index == len(item) - 1 else prefixes[1])
				print_single_task(subtask, verbose=verbose, prefix=prefix)
		else:
			print_single_task(item, verbose=verbose)

def print_single_task(task, verbose=False, prefix=None):
	priority = '[{0}] '.format(task.priority) if verbose else ''
	prefix = '{0} '.format(prefix) if prefix else ''
	try:
		print(prefix + priority + str(task))
	except UnicodeError:
		print(prefix + priority + str(task).encode(sys.stdout.encoding, errors='replace').decode(sys.stdout.encoding))

@cli.command('sort')
@utils.exits_with_return_value
def sort_Tasks():
	config = clckwrkbdgr.todo.read_config()
	tasklist_class = config.tasklist or clckwrkbdgr.todo.tasklist.TaskList
	tasklist = tasklist_class()
	return tasklist.sort()

@cli.command()
@click.option('-e', '--exclude', multiple=True, default=[], help='Exclude these paths from search. Paths can be either relative to the current dir or absolute.')
@click.option('-o', '--output-file', help='Output file to store found results. If no entries were found, file will not be touched. By default prints to stdout, and color is applied if output is terminal.')
@utils.exits_with_return_value
def search(exclude=None, output_file=None):
	exclude = [Path(path).absolute() for path in (exclude or [])]
	if not sys.stderr.isatty() or output_file:
		os.environ['ANSI_COLORS_DISABLED'] = '1'

	MARKERS = re.compile(r'(TO''DO|FIX''ME)')
	files = clckwrkbdgr.fs.find('.',
			exclude_dir_names=['.git'],
			exclude_extensions=['.sqlite', '.pyc'],
			exclude_wildcards=exclude,
			handle_dirs=track_directory if not output_file else (lambda _:_),
			)
	first_result = True
	for filename in files:
		for line_number, search_result in clckwrkbdgr.todo.search.search_in_file(filename, MARKERS):
			if line_number:
				line = format_file_line(filename, line_number, colored_matches(search_result))
			else:
				line = format_file_line(filename, 0, search_result)
			if output_file:
				mode = 'wb' if first_result else 'ab+'
				with open(output_file, mode) as f:
					try:
						f.write(line.encode('utf-8', 'replace'))
					except:
						f.write(line.encode('ascii', 'replace'))
					f.write(b'\n')
			else:
				print(line)
			first_result = False

if __name__ == '__main__':
	cli()
