#!/usr/bin/env python
import os, sys, re, subprocess
import logging
logger = logging.getLogger('todo')
import platform
import click, click_default_group
import json
import termcolor
from pathlib import Path
from clckwrkbdgr import utils, xdg
from clckwrkbdgr.collections import dotdict
import clckwrkbdgr.click
import clckwrkbdgr.todo
import clckwrkbdgr.todo.search
import clckwrkbdgr.todo.tasklist
import clckwrkbdgr.fs
import clckwrkbdgr.logging

def format_file_line(filename, line_number, value):
	""" Formats colored search result line:
	  <filename>:<line number>:<line>
	If line_number is 0 or None, treats value as error message and formats without line number:
	  <filename>:<message>
	"""
	result = termcolor.colored(str(filename), 'magenta') + termcolor.colored(':', 'cyan')
	if line_number:
		result += termcolor.colored(str(line_number), 'green') + termcolor.colored(':', 'cyan')
	if line_number:
		result += str(value)
	else:
		result += termcolor.colored(str(value), 'red')
	return result

def colored_matches(matches):
	""" Marks matched patterns found in string line with bold green color. """
	result = ''
	is_marker = False
	for m in matches:
		if is_marker:
			m = termcolor.colored(m, 'green', attrs=['bold'])
		result += m
		is_marker = not is_marker
	return result

def track_directory(dirpath):
	if not sys.stderr.isatty():
		return
	sys.stderr.write(str(dirpath))
	sys.stderr.write('\r')

@clckwrkbdgr.click.windows_noexpand_args
@click.group(cls=click_default_group.DefaultGroup, default='inbox', default_if_no_args=True, epilog=clckwrkbdgr.todo.CONFIG_FILE_DESC)
@click.option('--debug', is_flag=True, help='Enables debug output.')
@click.option('--config-file', help='Custom config file.')
@click.pass_context
def cli(ctx, debug=False, config_file=None):
	config = clckwrkbdgr.todo.read_config(config_file=config_file) # Pre-loading configuration.
	ctx.obj = config
	clckwrkbdgr.logging.init('todo', debug=debug)

@cli.command()
@click.argument('add_notes', nargs=-1)
@click.pass_obj
@utils.exits_with_return_value
def inbox(config, add_notes=None):
	config.inbox_file.parent.mkdir(parents=True, exist_ok=True)
	if not add_notes and not sys.stdin.isatty():
		add_notes = [sys.stdin.read().rstrip()]
	if add_notes:
		new_data = ' '.join(add_notes) + '\n'
		if config.prepend_inbox:
			with config.inbox_file.open('r+') as f:
				old_data = f.read()
				f.seek(0)
				f.write(new_data + old_data)
		else:
			with config.inbox_file.open('a+') as f:
				f.write(new_data)
		return True
	filename = str(config.inbox_file)
	if platform.system() == 'Windows':
		# On win32 if vim starts with single file and it contains backslashes,
		# Vim changes CWD to the base dir of the file.
		# To prevent this, slashes should be forward: C:/path/to/file
		filename = filename.replace('\\', '/')
	return 0 == subprocess.call(config.editor + [filename], shell=(platform.system() == 'Windows'))

@cli.command('sync')
@click.pass_obj
@utils.exits_with_return_value
def sync_tasks(config):
	tasklist_class = config.tasklist or clckwrkbdgr.todo.tasklist.TaskList
	tasklist = tasklist_class()
	ok = tasklist.sync()
	return ok

@cli.command('list')
@click.option('-v', '--verbose', is_flag=True, help='Display priority legend for each task.')
@click.pass_obj
@utils.exits_with_return_value
def list_tasks(config, verbose=False):
	tasklist_class = config.tasklist or clckwrkbdgr.todo.tasklist.TaskList
	tasklist = tasklist_class()
	prefixes = (
			termcolor.colored('+', 'magenta', attrs=['bold']),
			termcolor.colored('|', 'magenta'),
			termcolor.colored('\\', 'magenta'),
			)
	for item in tasklist.list_all(with_groups=True):
		if utils.is_collection(item):
			for index, subtask in enumerate(item):
				prefix = prefixes[0] if index == 0 else (prefixes[2] if index == len(item) - 1 else prefixes[1])
				print_single_task(subtask, verbose=verbose, prefix=prefix)
		else:
			print_single_task(item, verbose=verbose)

def print_single_task(task, verbose=False, prefix=None):
	priority_color = 'green'
	if task.priority.urgent and task.priority.important:
		priority_color = 'red'
	elif task.priority.urgent or task.priority.important:
		priority_color = 'yellow'
	priority = '{1}{0}{2} '.format(
			termcolor.colored(str(task.priority), priority_color),
			termcolor.colored('[', priority_color),
			termcolor.colored(']', priority_color),
			) if verbose else ''
	prefix = '{0} '.format(prefix) if prefix else ''
	tags = (' ' + termcolor.colored(''.join('[{}]'.format(tag) for tag in sorted(task.tags)), 'cyan')) if task.tags and verbose else ''
	try:
		print(prefix + priority + str(task) + tags)
	except UnicodeError:
		print((prefix + priority + str(task) + tags).encode(sys.stdout.encoding, errors='replace').decode(sys.stdout.encoding))

@cli.command('sort')
@click.pass_obj
@utils.exits_with_return_value
def sort_tasks(config):
	tasklist_class = config.tasklist or clckwrkbdgr.todo.tasklist.TaskList
	tasklist = tasklist_class()
	return tasklist.sort()

### SEARCH #####################################################################

SEARCH_PROJECT_ROOT = xdg.save_state_path('todo_search')

@cli.group('search', cls=click_default_group.DefaultGroup, default='direct', default_if_no_args=True)
def search():
	""" Search for TODO markers or similar tech-debt entries. """
	pass

@search.command('direct')
@click.option('--rc', is_flag=True, help='Return number of found entries as exit code. By default will always return 0 when no other errors found.')
@click.option('-e', '--exclude', multiple=True, default=[], help='Exclude these paths from search. Paths can be either relative to the current dir or absolute.')
@click.option('-o', '--output-file', help='Output file to store found results. If no entries were found, file will not be touched. By default prints to stdout, and color is applied if output is terminal.')
@utils.exits_with_return_value
def search_direct(exclude=None, output_file=None, rc=False):
	""" Searches for todo markers in current directory.
	"""
	if not sys.stderr.isatty() or output_file:
		os.environ['ANSI_COLORS_DISABLED'] = '1'
	found_entries = perform_todo_search(exclude=exclude, output_file=output_file)
	if rc:
		return found_entries

def perform_todo_search(exclude=None, output_file=None):
	exclude = [Path(path).absolute() for path in (exclude or [])]

	MARKERS = re.compile(r'(TO''DO|FIX''ME)')
	files = clckwrkbdgr.fs.find('.',
			exclude_dir_names=['.git'],
			exclude_extensions=['.sqlite', '.pyc'],
			exclude_wildcards=exclude,
			handle_dirs=track_directory if not output_file else (lambda _:_),
			)
	first_result = True
	found_entries = 0
	for filename in files:
		for line_number, search_result in clckwrkbdgr.todo.search.search_in_file(filename, MARKERS):
			found_entries += 1
			if line_number:
				line = format_file_line(filename, line_number, colored_matches(search_result))
			else:
				line = format_file_line(filename, 0, search_result)
			if output_file:
				mode = 'wb' if first_result else 'ab+'
				with open(output_file, mode) as f:
					try:
						f.write(line.encode('utf-8', 'replace'))
					except:
						f.write(line.encode('ascii', 'replace'))
					f.write(b'\n')
			else:
				print(line)
			first_result = False
	return found_entries

@search.command('collect')
@click.argument('project_name')
@click.option('-e', '--exclude', multiple=True, default=[], help='Exclude these paths from search. Paths can be either relative to the current dir or absolute.')
def collect_search(project_name, exclude=None):
	""" Collects todo entries in current directory and stores under given PROJECT_NAME.
	"""
	os.environ['ANSI_COLORS_DISABLED'] = '1'
	entry = SEARCH_PROJECT_ROOT/project_name
	found_entries = perform_todo_search(exclude=exclude, output_file=entry)
	if not found_entries and entry.exists():
		entry.unlink()

@search.command('show')
@click.argument('project_name')
@utils.exits_with_return_value
def show_collected_search(project_name):
	""" Displays all collected todo entries under given PROJECT_NAME.
	"""
	entry = SEARCH_PROJECT_ROOT/project_name
	if not entry.exists():
		return 1
	sys.stdout.write(entry.read_text())

@search.command('list')
def list_collected_search():
	""" List all currently collected batches by project names.
	"""
	for entry in SEARCH_PROJECT_ROOT.iterdir():
		print(entry.name)

if __name__ == '__main__':
	cli()
