#!/usr/bin/env python
import os, sys, re, subprocess
import platform
import click, click_default_group
import json
import termcolor
from pathlib import Path
from clckwrkbdgr import utils, xdg
from clckwrkbdgr.collections import dotdict

CONFIG_FILE_DESC = """Configuration is stored in $XDG_DATA_HOME/todo/config.json

\b
Fields:
- editor: Command to run editor (list of arguments). Filename will be added to the end of the arg list. Default is [$EDITOR].
- inbox_file: path to INBOX file (may contain tilde and environment variables). Default is "~/.local/share/todo/.INBOX.md"
"""

def read_config():
	config_file = xdg.save_data_path('todo')/'config.json'
	data = {}
	if config_file.exists():
		data = json.loads(config_file.read_text())
	return dotdict(
			inbox_file=Path(os.path.expandvars(data.get('inbox_file', "~/.local/share/todo/.INBOX.md"))).expanduser(),
			editor=list(data.get('editor', [os.environ.get('EDITOR', 'vim')])),
			)

@click.group(cls=click_default_group.DefaultGroup, default='inbox', default_if_no_args=True, epilog=CONFIG_FILE_DESC)
def cli():
	pass

@cli.command()
@click.argument('add_notes', nargs=-1)
@utils.exits_with_return_value
def inbox(add_notes=None):
	config = read_config()
	config.inbox_file.parent.mkdir(parents=True, exist_ok=True)
	if add_notes:
		with config.inbox_file.open('a+') as f:
			f.write(' '.join(add_notes) + '\n')
		return True
	filename = str(config.inbox_file)
	if platform.system() == 'Windows':
		# On win32 if vim starts with single file and it contains backslashes,
		# Vim changes CWD to the base dir of the file.
		# To prevent this, slashes should be forward: C:/path/to/file
		filename = filename.replace('\\', '/')
	return 0 == subprocess.call(config.editor + [filename], shell=True)

@cli.command()
@click.option('-e', '--exclude', multiple=True, default=[], help='Exclude these paths from search. Paths can be either relative to the current dir or absolute.')
@utils.exits_with_return_value
def search(exclude=None):
	exclude = [Path(path).absolute() for path in (exclude or [])]
	if not sys.stderr.isatty():
		os.environ['ANSI_COLORS_DISABLED'] = '1'

	MARKERS = re.compile(r'(TO''DO|FIX''ME)')
	for root, dirs, files in os.walk('.'):
		dirs[:] = [dirname for dirname in dirs if dirname not in ['.git']]
		dirs[:] = [dirname for dirname in dirs if (Path(root)/dirname).absolute() not in exclude]
		if sys.stderr.isatty():
			sys.stderr.write(root)
			sys.stderr.write('\r')
		for filename in files:
			filename = (Path(root)/filename)
			if filename.absolute() in exclude:
				continue
			if filename.suffix in ['.sqlite', '.pyc']:
				continue
			try:
				if not filename.exists():
					continue
				for index, line in enumerate(filename.read_bytes().splitlines(), 1):
					try:
						line = line.decode('utf-8', 'replace')
						matches = MARKERS.split(line)
						if len(matches) > 1:
							sys.stdout.write(termcolor.colored(str(filename), 'magenta') + termcolor.colored(':', 'cyan') + termcolor.colored(str(index), 'green') + termcolor.colored(':', 'cyan'))
							is_marker = False
							for m in matches:
								if is_marker:
									m = termcolor.colored(m, 'green', attrs=['bold'])
								sys.stdout.write(m)
								is_marker = not is_marker
							sys.stdout.write('\n')
					except Exception as e:
						print(termcolor.colored(str(filename), 'magenta') + termcolor.colored(':', 'cyan') + termcolor.colored(str(e), 'red'))
						continue
			except Exception as e:
				print(termcolor.colored(str(filename), 'magenta') + termcolor.colored(':', 'cyan') + termcolor.colored(str(e), 'red'))
				continue

if __name__ == '__main__':
	cli()
