#!/usr/bin/env python
import os, sys, subprocess
import re, fnmatch
import inspect
import argparse

def unfold_list(seq):
	return [item for subseq in seq for item in subseq]

class Environment(object):
	""" Keeps track of variables which can be used in config substitution.
	See --enviro argument.
	"""
	def __init__(self):
		self.envvars = {} # name: value
		self.known_vars = {} # name: lambda
	def known_names(self):
		""" Returns list of names of the known variables. """
		return self.known_vars.keys()
	def register(self, name, loader):
		""" Registers new variable with 'loader' function
		which is used to get the value.
		"""
		self.known_vars[name] = loader
	def get(self, name):
		""" Returns value of the specified variable. """
		if name not in self.envvars:
			self.envvars[name] = self.known_vars[name]()
		return self.envvars[name]

"""
xml:
	delete tag (full node) by xpath
	delete
	replace attribute value by xpath
	sort ?
	sort-xml - sort tags by attribute

json:
	pretty json (consider it as sort ?? or maybe the other way around: consider prettification and it would be sort for xml/ini/etc)

firefox pref.js
	user_pref("accessibility.blockautorefresh", true);
	delete preference by pattern (including regexp and wildcard)
	replace preference value by name and possibly regexp pattern with match groups

ini:
	sort sections/ sort values in sections
	delete ini setting by section/name
	delete whole section
	including search by regexp
	replace value for given section/name to another one
	including regexp and regexp match groups

scheme:
	delete value by setting name (including regex in names)
	"""

class ConfigFilter:
	""" Basic class for config filter.
	Should be created for specific content.
	Supports several actions performed on this content, see ACTIONS in args.
	"""
	def __init__(self, content):
		self.content = content
	@classmethod
	def description(filterclass):
		docs = [
				inspect.getdoc(filterclass),
				inspect.getdoc(filterclass.sort),
				]
		return '\n'.join(docs)
	def sort(self):
		raise NotImplementedError
	def delete(self, pattern, pattern_type=None):
		raise NotImplementedError

class PlainText(ConfigFilter):
	""" Plain-text config (or unknown format). """
	def sort(self):
		""" Sorting is performed by lines alphabetically. """
		ends_with_cr = self.content.endswith('\n')
		self.content = '\n'.join(sorted(self.content.splitlines()))
		if ends_with_cr:
			self.content += '\n'
	def delete(self, pattern, pattern_type=None):
		""" Removes lines that contain specified substring/regex/wildcard. """
		ends_with_cr = self.content.endswith('\n')
		lines = self.content.splitlines()
		if pattern_type == 'regex':
			pattern = re.compile(pattern)
		elif pattern_type == 'wildcard':
			pattern = fnmatch.translate(pattern)
		else:
			class DummyPattern:
				def __init__(self, expr):
					self.expr = expr
				def match(self, line):
					return self.expr in line
			pattern = DummyPattern(pattern)
		lines = [line for line in lines if not pattern.match(line)]
		self.content = '\n'.join(lines)
		if ends_with_cr:
			self.content += '\n'

def parse_args():
	FORMATS = {
			'txt' : PlainText,
			}
	epilog = 'FORMATS:\n' + '\n'.join(['{0}  - {1}'.format(key, filterclass.description()) for key, filterclass in FORMATS.items()])

	parser = argparse.ArgumentParser(
			description="Script to filter configuration files. "
			"Can process content with actions like sorting, replacing value, "
			"deleting value etc, see ACTIONS below.",
			epilog=epilog
			)
	parser.add_argument('-f', '--format', nargs=1, required=True,
			choices=FORMATS.keys(),
			help="Format of configuration file. "
			"See last section FORMATS for description of formats and actions. "
			"Supported formats: " + ', '.join(FORMATS.keys()))
	parser.add_argument('-e', '--enviro', nargs=1, action='append',
			help="Custom variable for usage in filtering. "
			"Its value will be substitude with its name wherever found upon "
			"filtering, and will be substituted back with the value for the "
			"current system upon restoring. "
			"Should be in form NAME=VALUE, where value is either "
			"environment variable with dollar sign, e.g.: `HOME=$HOME`, "
			"or command which prints value to stdout, e.g.: `HOME=echo $HOME`. "
			"By default only $HOME is recognized."
			)

	actions = parser.add_subparsers(dest='action',
			help='List of available actions. By default content will be passed as-is. '
			'Effects of each action depend on specified format.')

	restore_action = actions.add_parser('restore',
			help='Restore filtered config file to normal state instead of filtering.')

	enviro_action = actions.add_parser('enviro',
			help='Dummy action for the cases when only environment variables are needed to be expanded.'
			'Every other action will do the same expansion but "enviro" will do nothing except that.'
			)

	sort_action = actions.add_parser('sort', help='Sort content depending on format.')

	delete_action = actions.add_parser('delete',
			help='Delete entries that match specified patterns/paths (depends on format).')
	delete_action.add_argument('patterns', nargs='+', action='append', default=[], help='Patterns or paths.')
	delete_action.add_argument('--pattern-type', default='plain', choices='plain regex wildcard'.split(),
			help="Sets type of the supplied pattern (if any and if recognizable by current format)."
			)

	settings = parser.parse_args()
	settings.format = FORMATS[settings.format[0]]
	settings.enviro = [x for s in settings.enviro for x in s] if settings.enviro else []
	if settings.action == 'delete':
		settings.patterns = unfold_list(settings.patterns)
	return settings

def prepare_envvars(enviro_args):
	""" Registers requested environment variables and returns prepared Environment.
	Built-in variables: $HOME.
	"""
	envvars = Environment()
	envvars.register('HOME', lambda: os.getenv('HOME'))
	for enviro in enviro_args:
		if not '=' in enviro:
			raise Exception('Expected NAME=VALUE for -e argument, got {0}'.format(enviro))
		name, value = enviro.split('=', 1)
		if value.startswith('$'):
			varname = value[1:]
			if os.getenv(varname) is None:
				raise Exception('Environment variable {0} is not defined!'.format(varname))
			envvars.register(name, lambda varname=varname: os.getenv(varname))
		else:
			envvars.register(name, lambda command=value: subprocess.check_output(command, shell=True).rstrip('\n'))
	return envvars

def main():
	settings = parse_args()
	envvars = prepare_envvars(settings.enviro)

	content = sys.stdin.read()
	if settings.action == 'restore':
		for name in envvars.known_names():
			placeholder = '${0}'.format(name)
			if placeholder in content:
				content = content.replace(placeholder, envvars.get(name))
	else:
		filter = settings.format(content)
		if settings.action == 'sort':
			filter.sort()
		elif settings.action == 'delete':
			for pattern in settings.patterns:
				filter.delete(pattern, settings.pattern_type)
		content = filter.content
		for name in envvars.known_names():
			placeholder = '${0}'.format(name)
			content = content.replace(envvars.get(name), placeholder)
	sys.stdout.write(content)

if __name__ == "__main__":
	ok = main()
	if ok is not None and not ok:
		sys.exit(1)
