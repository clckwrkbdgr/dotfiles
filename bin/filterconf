#!/usr/bin/env python
import os, sys, subprocess
import types, functools
import re, fnmatch
import inspect
import shlex
from collections import OrderedDict
import click
from clckwrkbdgr import utils

class Environment(object):
	""" Keeps track of variables which can be used in config substitution.
	See --enviro argument.
	"""
	def __init__(self):
		self.envvars = OrderedDict() # name: value
		self.known_vars = OrderedDict() # name: lambda
	def known_names(self):
		""" Returns list of names of the known variables. """
		return self.known_vars.keys()
	def register(self, name, loader):
		""" Registers new variable with 'loader' function
		which is used to get the value.
		"""
		self.known_vars[name] = loader
	def get(self, name):
		""" Returns value of the specified variable. """
		if name not in self.envvars:
			self.envvars[name] = self.known_vars[name]()
		return self.envvars[name]

"""
xml:
	delete tag (full node) by xpath
	delete
	replace attribute value by xpath
	sort ?
	sort-xml - sort tags by attribute

json:
	pretty json (consider it as sort ?? or maybe the other way around: consider prettification and it would be sort for xml/ini/etc)

firefox pref.js
	user_pref("accessibility.blockautorefresh", true);
	delete preference by pattern (including regexp and wildcard)
	replace preference value by name and possibly regexp pattern with match groups

ini:
	sort sections/ sort values in sections
	delete ini setting by section/name
	delete whole section
	including search by regexp
	replace value for given section/name to another one
	including regexp and regexp match groups

scheme:
	delete value by setting name (including regex in names)
	"""

class ConfigFilter:
	""" Basic class for config filter.
	Should be created for specific content.
	Supports several actions performed on this content, see ACTIONS in args.
	"""
	def __init__(self, content):
		self.content = content
	@classmethod
	def description(filterclass):
		docs = [
				inspect.getdoc(filterclass),
				inspect.getdoc(filterclass.sort),
				]
		return '\n'.join(docs)
	def sort(self):
		raise NotImplementedError
	def delete(self, pattern, pattern_type=None):
		raise NotImplementedError
	def replace(self, pattern, substitute, pattern_type=None):
		raise NotImplementedError
	def pretty(self):
		raise NotImplementedError

class ConfigFilterRegistry:
	def __init__(self):
		self._registry = {}
	def __call__(self, filter_name):
		def _actual(cls):
			assert filter_name not in self._registry, 'Cannot add another ConfigFilter class under name {0}'.format(repr(filter_name))
			self._registry[filter_name] = cls
			return cls
		return _actual
	def __getitem__(self, name):
		return self._registry[name]
	def known_names(self):
		return list(self._registry.keys())

config_filter = ConfigFilterRegistry()

@config_filter('txt')
class PlainText(ConfigFilter):
	""" Plain-text config (or unknown format). """
	def sort(self):
		""" Sorting is performed by lines alphabetically. """
		ends_with_cr = self.content.endswith('\n')
		self.content = '\n'.join(sorted(self.content.splitlines()))
		if ends_with_cr:
			self.content += '\n'
	def delete(self, pattern, pattern_type=None):
		""" Removes lines that contain specified substring/regex/wildcard. """
		ends_with_cr = self.content.endswith('\n')
		lines = self.content.splitlines()

		if pattern_type == 'regex':
			pattern = re.compile(pattern)
		elif pattern_type == 'wildcard':
			pattern = fnmatch.translate(pattern)
		else:
			class DummyPattern:
				def __init__(self, expr):
					self.expr = expr
				def match(self, line):
					return self.expr in line
			pattern = DummyPattern(pattern)

		lines = [line for line in lines if not pattern.match(line)]
		self.content = '\n'.join(lines)
		if ends_with_cr:
			self.content += '\n'
	def replace(self, pattern, substitute, pattern_type=None):
		""" Replaces value specified by substring/regex with substitute. """
		ends_with_cr = self.content.endswith('\n')
		lines = self.content.splitlines()

		if pattern_type == 'regex':
			pattern = re.compile(pattern)
		else:
			class DummyPattern:
				def __init__(self, expr):
					self.expr = expr
				def match(self, line):
					return self.expr in line
				def sub(self, repl, line):
					return line.replace(self.expr, repl)
			pattern = DummyPattern(pattern)
		lines = [(pattern.sub(substitute, line) if pattern.match(line) else line) for line in lines]

		self.content = '\n'.join(lines)
		if ends_with_cr:
			self.content += '\n'
	def pretty(self):
		""" Plain text cannot be prettified. """
		pass

def get_epilog():
	result = 'FORMATS:\n'
	for name in config_filter.known_names():
		filterclass = config_filter[name]
		result +=   '  {0}  - '.format(name)
		result += '\n         '.join(filterclass.description().splitlines())
	return result

def prepare_envvars(enviro_args):
	""" Registers requested environment variables and returns prepared Environment.
	Built-in variables: $HOME.
	"""
	envvars = Environment()
	envvars.register('HOME', lambda: os.getenv('HOME'))
	for enviro in enviro_args:
		if not '=' in enviro:
			raise Exception('Expected NAME=VALUE for -e argument, got {0}'.format(enviro))
		name, value = enviro.split('=', 1)
		if value.startswith('$'):
			varname = value[1:]
			if os.getenv(varname) is None:
				raise Exception('Environment variable {0} is not defined!'.format(varname))
			envvars.register(name, lambda varname=varname: os.getenv(varname))
		else:
			envvars.register(name, lambda command=value: subprocess.check_output(command, shell=True).decode('utf-8', 'replace').rstrip('\n'))
	return envvars

class RawEpilogGroup(click.Group):
	def format_epilog(self, ctx, formatter):
		if self.epilog:
			formatter.write_paragraph()
			for line in self.epilog.split('\n'):
				formatter.write_text(line)

@click.group(cls=RawEpilogGroup, epilog=get_epilog())
@click.option('-f', '--format', required=True, type=click.Choice(config_filter.known_names()),
		callback=lambda ctx, param, value: config_filter[value],
		help="Format of configuration file. "
		"See last section FORMATS for description of formats and actions. "
		"Supported formats: " + ', '.join(config_filter.known_names()))
@click.option('-e', '--enviro', multiple=True, default=[],
		help="Custom variable for usage in filtering. "
		"Its value will be substitude with its name wherever found upon "
		"filtering, and will be substituted back with the value for the "
		"current system upon restoring. "
		"Should be in form NAME=VALUE, where value is either "
		"environment variable with dollar sign, e.g.: `HOME=$HOME`, "
		"or command which prints value to stdout, e.g.: `HOME=echo $HOME`. "
		"By default only $HOME is recognized.")
@click.pass_context
@utils.returns_exit_code
def main(ctx, format=None, enviro=None):
	""" Script to filter configuration files.
	Can process content with actions like sorting, replacing value,
	deleting value etc, see ACTIONS below.
	"""
	ctx.ensure_object(types.SimpleNamespace)
	ctx.obj.envvars = prepare_envvars(enviro)
	ctx.obj.format = format

def with_stdin_content(enviro_action=None):
	""" Reads stdin content and adds to context object under .content.
	After execution writes content back to stdout.
	If enviro_action = 'expand', expands environment variables in .envvars.
	If enviro_action = 'restore', smudges environment variables in .envvars.
	If incoming context object already has .content, all content actions are skipped.
	"""
	def _actual(func):
		@functools.wraps(func)
		def _wrapper(settings, *args, **kwargs):
			has_content = hasattr(settings, 'content')
			if not has_content:
				settings.content = sys.stdin.read()
				if enviro_action == 'expand':
					for name in settings.envvars.known_names():
						placeholder = '${0}'.format(name)
						settings.content = settings.content.replace(settings.envvars.get(name), placeholder)
				elif enviro_action == 'restore':
					for name in settings.envvars.known_names():
						placeholder = '${0}'.format(name)
						if placeholder in settings.content:
							settings.content = settings.content.replace(placeholder, settings.envvars.get(name))
				elif enviro_action is not None:
					raise ValueError("enviro_action should be either None, 'expand' or 'restore'")
			try:
				rc = func(settings, *args, **kwargs)
			finally:
				if not has_content:
					sys.stdout.write(settings.content)
					delattr(settings, 'content')
			return rc
		return _wrapper
	return _actual

@main.command()
@click.pass_obj
@with_stdin_content(enviro_action='restore')
@utils.returns_exit_code
def restore(settings):
	""" Restore filtered config file to normal state instead of filtering. """
	pass

@main.command()
@click.pass_obj
@with_stdin_content(enviro_action='expand')
@utils.returns_exit_code
def enviro(settings):
	""" Dummy action for the cases when only environment variables are needed to be expanded.
	Every other action will do the same expansion but "enviro" will do nothing except that.
	"""
	pass

@main.command()
@click.pass_obj
@with_stdin_content(enviro_action='expand')
@utils.returns_exit_code
def sort(settings):
	""" Sort content depending on format. """
	filter = settings.format(settings.content)
	filter.sort()
	settings.content = filter.content

@main.command()
@click.argument('patterns', nargs=-1)
@click.option('--pattern-type', default='plain', type=click.Choice('plain regex wildcard'.split()),
			help="Sets type of the supplied pattern (if any and if recognizable by current format)."
			)
@click.pass_obj
@with_stdin_content(enviro_action='expand')
@utils.returns_exit_code
def delete(settings, patterns, pattern_type=None):
	""" Delete entries that match specified patterns/paths (depends on format). """
	filter = settings.format(settings.content)
	for pattern in patterns:
		filter.delete(pattern, pattern_type)
	settings.content = filter.content

@main.command()
@click.argument('pattern')
@click.option('--pattern-type', default='plain', type=click.Choice('plain regex wildcard'.split()),
			help="Sets type of the supplied pattern (if any and if recognizable by current format)."
			)
@click.option('--with', 'with_value', nargs=1, required=True,
			help="Value to substitute. May contain references to the original value like refgroups for regexes (depends on format and pattern type)."
			)
@click.pass_obj
@with_stdin_content(enviro_action='expand')
@utils.returns_exit_code
def replace(settings, pattern, pattern_type=None, with_value=None):
	""" Replace entry specified by pattern/path with another value (depends on format). """
	filter = settings.format(settings.content)
	filter.replace(pattern, with_value, pattern_type)
	settings.content = filter.content

@main.command()
@click.pass_obj
@with_stdin_content(enviro_action='expand')
@utils.returns_exit_code
def pretty(settings):
	""" Prettify content depending on format. """
	filter = settings.format(settings.content)
	filter.pretty()
	settings.content = filter.content

@main.command()
@click.argument('filename')
@click.pass_obj
@with_stdin_content(enviro_action='expand')
@utils.returns_exit_code
def script(settings, filename):
	""" Run several commands, stored in script file.
	Commands are applied in the given order.
	Format and enviro options do not need to be specified for each command,
	they are taken from main command line.
	"""
	with open(filename) as f:
		for line in f:
			if not line.strip() or line.lstrip().startswith('#'):
				continue
			try:
				command_name, *args = shlex.split(line)
				try:
					command = globals()[command_name]
				except KeyError:
					raise ValueError('Unknown command: {0}. See usage for list of available commands.'.format(command))
				if not isinstance(command, click.core.Command):
					raise ValueError('Unknown command: {0}. See usage for list of available commands.'.format(command))
				rc = command(args=args, standalone_mode=False, obj=settings)
			except SystemExit as e:
				rc = e.code
			if rc != 0:
				return rc

if __name__ == "__main__":
	main()
