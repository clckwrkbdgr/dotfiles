#!/usr/bin/env python
import os, sys, subprocess
import re, fnmatch
import inspect
import argparse, shlex
from collections import OrderedDict

class UnfoldArgList(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		getattr(namespace, self.dest).extend(values)

class TakeFirstArg(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		setattr(namespace, self.dest, values[0])

class Environment(object):
	""" Keeps track of variables which can be used in config substitution.
	See --enviro argument.
	"""
	def __init__(self):
		self.envvars = OrderedDict() # name: value
		self.known_vars = OrderedDict() # name: lambda
	def known_names(self):
		""" Returns list of names of the known variables. """
		return self.known_vars.keys()
	def register(self, name, loader):
		""" Registers new variable with 'loader' function
		which is used to get the value.
		"""
		self.known_vars[name] = loader
	def get(self, name):
		""" Returns value of the specified variable. """
		if name not in self.envvars:
			self.envvars[name] = self.known_vars[name]()
		return self.envvars[name]

"""
xml:
	delete tag (full node) by xpath
	delete
	replace attribute value by xpath
	sort ?
	sort-xml - sort tags by attribute

json:
	pretty json (consider it as sort ?? or maybe the other way around: consider prettification and it would be sort for xml/ini/etc)

firefox pref.js
	user_pref("accessibility.blockautorefresh", true);
	delete preference by pattern (including regexp and wildcard)
	replace preference value by name and possibly regexp pattern with match groups

ini:
	sort sections/ sort values in sections
	delete ini setting by section/name
	delete whole section
	including search by regexp
	replace value for given section/name to another one
	including regexp and regexp match groups

scheme:
	delete value by setting name (including regex in names)
	"""

class ConfigFilter:
	""" Basic class for config filter.
	Should be created for specific content.
	Supports several actions performed on this content, see ACTIONS in args.
	"""
	def __init__(self, content):
		self.content = content
	@classmethod
	def description(filterclass):
		docs = [
				inspect.getdoc(filterclass),
				inspect.getdoc(filterclass.sort),
				]
		return '\n'.join(docs)
	def sort(self):
		raise NotImplementedError
	def delete(self, pattern, pattern_type=None):
		raise NotImplementedError
	def replace(self, pattern, substitute, pattern_type=None):
		raise NotImplementedError
	def pretty(self):
		raise NotImplementedError

class PlainText(ConfigFilter):
	""" Plain-text config (or unknown format). """
	def sort(self):
		""" Sorting is performed by lines alphabetically. """
		ends_with_cr = self.content.endswith('\n')
		self.content = '\n'.join(sorted(self.content.splitlines()))
		if ends_with_cr:
			self.content += '\n'
	def delete(self, pattern, pattern_type=None):
		""" Removes lines that contain specified substring/regex/wildcard. """
		ends_with_cr = self.content.endswith('\n')
		lines = self.content.splitlines()

		if pattern_type == 'regex':
			pattern = re.compile(pattern)
		elif pattern_type == 'wildcard':
			pattern = fnmatch.translate(pattern)
		else:
			class DummyPattern:
				def __init__(self, expr):
					self.expr = expr
				def match(self, line):
					return self.expr in line
			pattern = DummyPattern(pattern)

		lines = [line for line in lines if not pattern.match(line)]
		self.content = '\n'.join(lines)
		if ends_with_cr:
			self.content += '\n'
	def replace(self, pattern, substitute, pattern_type=None):
		""" Replaces value specified by substring/regex with substitute. """
		ends_with_cr = self.content.endswith('\n')
		lines = self.content.splitlines()

		if pattern_type == 'regex':
			pattern = re.compile(pattern)
		else:
			class DummyPattern:
				def __init__(self, expr):
					self.expr = expr
				def match(self, line):
					return self.expr in line
				def sub(self, repl, line):
					return line.replace(self.expr, repl)
			pattern = DummyPattern(pattern)
		lines = [(pattern.sub(substitute, line) if pattern.match(line) else line) for line in lines]

		self.content = '\n'.join(lines)
		if ends_with_cr:
			self.content += '\n'
	def pretty(self):
		""" Plain text cannot be prettified. """
		pass

def add_action_arguments(parser):
	actions = parser.add_subparsers(dest='action',
			help='List of available actions. By default content will be passed as-is. '
			'Effects of each action depend on specified format.')

	restore_action = actions.add_parser('restore',
			help='Restore filtered config file to normal state instead of filtering.')

	enviro_action = actions.add_parser('enviro',
			help='Dummy action for the cases when only environment variables are needed to be expanded.'
			'Every other action will do the same expansion but "enviro" will do nothing except that.'
			)

	sort_action = actions.add_parser('sort', help='Sort content depending on format.')

	delete_action = actions.add_parser('delete',
			help='Delete entries that match specified patterns/paths (depends on format).')
	delete_action.add_argument('patterns', nargs='+', action=UnfoldArgList, default=[], help='Patterns or paths.')
	delete_action.add_argument('--pattern-type', default='plain', choices='plain regex wildcard'.split(),
			help="Sets type of the supplied pattern (if any and if recognizable by current format)."
			)

	replace_action = actions.add_parser('replace',
			help='Replace entry specified by patterns/paths with another value (depends on format).')
	replace_action.add_argument('pattern', nargs=1, action=TakeFirstArg, default=[], help='Pattern or path.')
	replace_action.add_argument('--pattern-type', default='plain', choices='plain regex wildcard'.split(),
			help="Sets type of the supplied pattern (if any and if recognizable by current format)."
			)
	replace_action.add_argument('--with', dest='with_value', nargs=1, required=True,
			action=TakeFirstArg,
			help="Value to substitute. May contain references to the original value like refgroups for regexes (depends on format and pattern type)."
			)

	pretty_action = actions.add_parser('pretty', help='Prettify content depending on format.')

	script_action = actions.add_parser('script',
			help='Run several commands, stored in script file. Commands are applied in the given order.')
	script_action.add_argument('filename', nargs=1, action=TakeFirstArg, default=[],
			help='File with commands. Each command have the same syntax as in command-line arguments.')

def parse_args():
	FORMATS = {
			'txt' : PlainText,
			}
	epilog = 'FORMATS:\n' + '\n'.join(['{0}  - {1}'.format(key, filterclass.description()) for key, filterclass in FORMATS.items()])

	parser = argparse.ArgumentParser(
			description="Script to filter configuration files. "
			"Can process content with actions like sorting, replacing value, "
			"deleting value etc, see ACTIONS below.",
			epilog=epilog
			)
	parser.add_argument('-f', '--format', nargs=1, required=True,
			action=TakeFirstArg,
			choices=FORMATS.keys(),
			help="Format of configuration file. "
			"See last section FORMATS for description of formats and actions. "
			"Supported formats: " + ', '.join(FORMATS.keys()))
	parser.add_argument('-e', '--enviro', nargs=1, action=UnfoldArgList, default=[],
			help="Custom variable for usage in filtering. "
			"Its value will be substitude with its name wherever found upon "
			"filtering, and will be substituted back with the value for the "
			"current system upon restoring. "
			"Should be in form NAME=VALUE, where value is either "
			"environment variable with dollar sign, e.g.: `HOME=$HOME`, "
			"or command which prints value to stdout, e.g.: `HOME=echo $HOME`. "
			"By default only $HOME is recognized."
			)

	add_action_arguments(parser)

	settings = parser.parse_args()
	settings.format = FORMATS[settings.format]
	return settings

def prepare_envvars(enviro_args):
	""" Registers requested environment variables and returns prepared Environment.
	Built-in variables: $HOME.
	"""
	envvars = Environment()
	envvars.register('HOME', lambda: os.getenv('HOME'))
	for enviro in enviro_args:
		if not '=' in enviro:
			raise Exception('Expected NAME=VALUE for -e argument, got {0}'.format(enviro))
		name, value = enviro.split('=', 1)
		if value.startswith('$'):
			varname = value[1:]
			if os.getenv(varname) is None:
				raise Exception('Environment variable {0} is not defined!'.format(varname))
			envvars.register(name, lambda varname=varname: os.getenv(varname))
		else:
			envvars.register(name, lambda command=value: subprocess.check_output(command, shell=True).decode('utf-8', 'replace').rstrip('\n'))
	return envvars

def perform_action(filter, settings):
	if settings.action == 'sort':
		filter.sort()
	elif settings.action == 'delete':
		for pattern in settings.patterns:
			filter.delete(pattern, settings.pattern_type)
	elif settings.action == 'replace':
		filter.replace(settings.pattern, settings.with_value, settings.pattern_type)
	elif settings.action == 'pretty':
		filter.pretty()
	elif settings.action == 'script':
		with open(settings.filename) as f:
			for line in f:
				if not line.strip() or line.lstrip().startswith('#'):
					continue
				parser = argparse.ArgumentParser()
				add_action_arguments(parser)
				command = parser.parse_args(shlex.split(line))
				perform_action(filter, command)
				pass
	return filter

def main():
	settings = parse_args()
	envvars = prepare_envvars(settings.enviro)

	content = sys.stdin.read()
	if settings.action == 'restore':
		for name in envvars.known_names():
			placeholder = '${0}'.format(name)
			if placeholder in content:
				content = content.replace(placeholder, envvars.get(name))
	else:
		for name in envvars.known_names():
			placeholder = '${0}'.format(name)
			content = content.replace(envvars.get(name), placeholder)
		filter = settings.format(content)
		filter = perform_action(filter, settings)
		content = filter.content
	sys.stdout.write(content)

if __name__ == "__main__":
	ok = main()
	if ok is not None and not ok:
		sys.exit(1)
