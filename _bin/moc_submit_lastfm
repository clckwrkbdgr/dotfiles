#!/usr/bin/python3

# A wrapper script that interfaces between MOC (Music on console) and
# lastfmsubmit.  The problem with just usnig OnSongChange is that it
# will be triggered even if you listen to only one second of a song.
# This script will wait for half the length of the track, checking
# whether MOC is still playing it, before submitting the track to
# last.fm.  This way, skipping through a list of tracks will not
# result in lots of tracks submitted.

#  To use, put this in your ~/.moc/config file:
# OnSongChange = "/path/to/moc_submit_lastfm --artist %a --title %t --length %d --album %r"

# Author: Luke Plant  < http://lukeplant.me.uk/ >
# License: public domain

from datetime import datetime
from optparse import OptionParser
from subprocess import check_call, call, Popen, PIPE
import time
import sys

parser = OptionParser()
parser.add_option("-a", "--artist", dest="artist")
parser.add_option("-t", "--title", dest="title")
parser.add_option("-A", "--album", dest="album")
parser.add_option("-l", "--length", dest="length")

# Treating everything as bytestrings throughout seems to work OK even
# with non-ASCII characters in song titles etc (at least with a UTF-8
# locale).

def still_playing(artist, album, title, length):
	p = Popen(["mocp", "-i"], stdout=PIPE)
	out, err = p.communicate()
	lines = out.decode('utf-8').split("\n")
	for s in ["Artist: %s" % artist, "Album: %s" % album, "SongTitle: %s" % title]:
		if not s in lines:
			return False
	return True

def submit_to_lastfm(artist, album, title, length):
	args = ["/usr/lib/lastfmsubmitd/lastfmsubmit", "--artist", artist, "--title", title, "--length", length]
	if album is not None:
		args.extend(["--album", album])
	try:
		check_call(args)
	except Exception as e:
		print("moc: {0}/{1}/{2}/{3}: ".format(artist,album,title,length), e)

def main():
	options, args = parser.parse_args()
	decoded_artist = options.artist #.encode('iso-8859-1').decode('utf-8')
	decoded_album = options.album #.encode('iso-8859-1').decode('utf-8')
	decoded_title = options.title #.encode('iso-8859-1').decode('utf-8')
	try:
		decoded_artist = options.artist.encode('iso-8859-1').decode('utf-8')
		decoded_album = options.album.encode('iso-8859-1').decode('utf-8')
		decoded_title = options.title.encode('iso-8859-1').decode('utf-8')
	except Exception as e:
		print("moc: {0}/{1}/{2}/{3}: ".format(options.artist,options.album,options.title,options.length), e)
	if any(not options.__dict__.get(k) for k in ["artist", "title", "length"]):
		print("moc: {0}/{1}/{2}/{3}: ".format(options.artist,options.album,options.title,options.length), "All of artist, album, length must be specified")
		exit(1)
	if ":" in options.length:
		mins, secs = options.length.split(":")
		length = int(mins) * 60 + int(secs)
	else:
		length = int(options.length)
	if length < 15:
		submit_to_lastfm(decoded_artist, decoded_album, decoded_title, options.length)
		exit(0)
	# wait until song is half played
	wait = length/2
	start = datetime.now()
	while True:
		time.sleep(5)
		if not still_playing(options.artist, options.album, options.title, options.length):
			exit(1)
		if (datetime.now() - start).seconds > wait:
			submit_to_lastfm(decoded_artist, decoded_album, decoded_title, options.length)
			exit(0)

if __name__ == '__main__':
	import sys
	home = os.path.expanduser("~")
	logfile = open(os.path.join(home, ".util.log", "a")
	sys.stdout = logfile
	sys.stderr = logfile
	try:
		main()
	except Exception as e:
		print(sys.argv, e)
