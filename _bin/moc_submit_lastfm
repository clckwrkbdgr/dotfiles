#!/usr/bin/python3
# A wrapper script that interfaces between MOC (Music on console) and
# lastfmsubmit.  The problem with just usnig OnSongChange is that it
# will be triggered even if you listen to only one second of a song.
# This script will wait for half the length of the track, checking
# whether MOC is still playing it, before submitting the track to
# last.fm.  This way, skipping through a list of tracks will not
# result in lots of tracks submitted.
#
# Modified version does also decoding values to unicode and guessing missing tags.
#
# To use, put this in your ~/.moc/config file:
#    OnSongChange = "/path/to/moc_submit_lastfm --artist %a --title %t --length %d --album %r --filename %f"
# Artist, title, length, and filename arguments are mandatory
#
# Original author: Luke Plant  < http://lukeplant.me.uk/ >
# Heavily modified by umi0451 <umi0451.github.io>
# License: WTFPLv2
import datetime
import optparse
import subprocess
import time
import sys
import os
import re
import unittest
import chardet

DEBUG = False

class TrackInfo:
	def __init__(self, artist=None, title=None, album=None, length=None, filename=None):
		other = artist
		if other is not None and hasattr(other, "artist"):
			self.artist = other.artist
			self.title = other.title
			self.album = other.album
			self.length = other.length
			self.filename = other.filename
		else:
			self.artist = artist
			self.title = title
			self.album = album
			self.length = length
			self.filename = filename

def extract_tags_from_filename(filename):
	info = TrackInfo()
	info.title = os.path.splitext(os.path.basename(filename))[0]
	m = re.match(r'[0-9]{,3} +[-]? +(.+)', info.title)
	if m:
		info.title = m.group(1)
	return info

def substitute_insufficient_info(original_info, extended_info):
	info = TrackInfo(original_info)
	if info.artist is None and extended_info.artist is not None:
		info.artist = extended_info.artist
	if info.album is None and extended_info.album is not None:
		info.album = extended_info.album
	if info.title is None and extended_info.title is not None:
		info.title = extended_info.title
	return info

def decode_info(original_info):
	info = TrackInfo(original_info)
	encoding = chardet.detect((info.artist + info.title).encode('latin1'))
	try:
		encoding = encoding["encoding"]
		info.artist = info.artist.encode('latin1').decode(encoding)
		info.album = info.album.encode('latin1').decode(encoding)
		info.title = info.title.encode('latin1').decode(encoding)
	except Exception as e:
		print(info.filename, encoding, e)
	return info

def convert_length(length):
	if ":" not in length:
		return int(length)
	mins, secs = length.split(":")
	return int(mins) * 60 + int(secs)

class TestExtractInfo(unittest.TestCase):
	def check_info(self, artist, album, title, info):
		if isinstance(info, str):
			info = extract_tags_from_filename(info)
		self.assertEqual(info.artist, artist)
		self.assertEqual(info.album, album)
		self.assertEqual(info.title, title)

	def test_should_substitute_insufficient_info(self):
		info = TrackInfo(artist="artist")
		extended = TrackInfo(artist="extended_artist", title="extended_title")
		info = substitute_insufficient_info(info, extended)
		self.check_info("artist", None, "extended_title", info)
	def test_should_extract_tags_from_filename(self):
		self.check_info("Artist", "Album", "Title", "/media/music/Artist/2000-Album/01-Title.mp3")
		self.check_info("Artist", None, "Title", "/media/music/Artist - Title.mp3")
		self.check_info("Artist", None, "Title", "/media/music/12-Artist/01-Title.mp3")
		self.check_info(None, "Album", "Title", "/media/music/2000 - Album/01-Title.mp3")

class TestDecoding(unittest.TestCase):
	def test_should_leave_ascii_as_is(self):
		info = TrackInfo(artist="artist", title="title", album="album")
		info = decode_info(info)
		self.assertEqual(info.artist, "artist")
		self.assertEqual(info.album, "album")
		self.assertEqual(info.title, "title")
	def test_should_recognize_utf_8(self):
		info = TrackInfo(artist="ÐÐ¸ÐºÐ½Ð¸Ðº", title="ÐÐ¾ÑÑ", album="ÐÑÐ¼")
		info = decode_info(info)
		self.assertEqual(info.artist, "Пикник")
		self.assertEqual(info.album, "Дым")
		self.assertEqual(info.title, "Ночь")
	def test_should_recognize_cp1251(self):
		info = TrackInfo(artist="Ñïëèí", title="Óâåðòþðà", album="Îáìàí çðåíèÿ")
		info = decode_info(info)
		self.assertEqual(info.artist, "Сплин")
		self.assertEqual(info.album, "Обман зрения")
		self.assertEqual(info.title, "Увертюра")
	def test_should_recognize_iso8859_1(self):
		info = TrackInfo(artist="The Gathering", title="Eléanor", album="Mandylion")
		info = decode_info(info)
		self.assertEqual(info.artist, "The Gathering")
		self.assertEqual(info.album, "Mandylion")
		self.assertEqual(info.title, "Eléanor")

class TestInfo(unittest.TestCase):
	def test_should_create_info_object_from_other_object(self):
		info = TrackInfo(title="some_title")
		cloned_info = TrackInfo(info)
		self.assertEqual(cloned_info.title, "some_title")
		cloned_info.title = ""
		self.assertEqual(info.title, "some_title")
	def test_should_recognize_full_specified_length(self):
		self.assertEqual(convert_length("10:10"), 10 * 60 + 10)
	def test_should_recognize_only_minutes_length(self):
		self.assertEqual(convert_length("10"), 10)

# Side-effect functions

def still_playing(info):
	p = subprocess.Popen(["mocp", "-i"], stdout=subprocess.PIPE)
	out, err = p.communicate()
	lines = out.decode('utf-8').split("\n")
	for s in ["Artist: %s" % info.artist, "Album: %s" % info.album, "SongTitle: %s" % info.title]:
		if not s in lines:
			return False
	return True

def submit_to_lastfm(info):
	args = ["/usr/lib/lastfmsubmitd/lastfmsubmit", "--artist", info.artist, "--title", info.title, "--length", str(info.length)]
	if info.album is not None:
		args.extend(["--album", info.album])
	if DEBUG:
		print(args)
		return
	try:
		subprocess.check_call(args)
	except Exception as e:
		print("moc: {0}: ".format(info.filename), e)

def wait_until_song_is_half_played(info):
	if info.length < 15:
		return True
	wait = info.length/2
	start = datetime.datetime.now()
	while True:
		time.sleep(5)
		if not still_playing(info):
			if DEBUG:
				print("not playing")
			return False
		if (datetime.datetime.now() - start).seconds > wait:
			return True

def main():
	parser = optparse.OptionParser()
	parser.add_option("-a", "--artist", dest="artist")
	parser.add_option("-t", "--title", dest="title")
	parser.add_option("-A", "--album", dest="album")
	parser.add_option("-l", "--length", dest="length")
	parser.add_option("-f", "--filename", dest="filename")
	options, args = parser.parse_args()
	mandatory = ["artist", "title", "length", "filename"]
	if any(not options.__dict__.get(k) for k in mandatory):
		print("moc: {0}: All of {1} must be specified".format(options.filename, ', '.join(mandatory)))
		exit(1)

	original_info = TrackInfo(options)
	original_info.length = convert_length(original_info.length)
	filename_info = extract_tags_from_filename(info.filename)
	original_info = substitute_insufficient_info(original_info, filename_info)
	decoded_info = decode_info(original_info)
	if wait_until_song_is_half_played(original_info):
		submit_to_lastfm(decoded_info)
		exit(0)
	else:
		exit(1)

if __name__ == '__main__':
	if len(sys.argv) > 1 and sys.argv[1] == "test":
		del sys.argv[1]
		unittest.main()

	if not DEBUG:
		home = os.path.expanduser("~")
		logfile = open(os.path.join(home, ".util.log"), "a")
		sys.stdout = logfile
		sys.stderr = logfile
	try:
		main()
	except Exception as e:
		print(sys.argv, e)
