import textwrap
from collections import defaultdict
from clckwrkbdgr.math import Matrix, Point, Size
import logging
Log = logging.getLogger('rogue')
from clckwrkbdgr import pcg
import clckwrkbdgr.pcg.cellular
import clckwrkbdgr.pcg.maze
import clckwrkbdgr.pcg.rogue
from clckwrkbdgr.pcg import bsp
import clckwrkbdgr.math
from ..engine import builders

class CustomMap(builders.Builder):
	""" Builds map described by custom layout.
	Forces map size to fit given layout instead of considering passed parameter.
	Set .MAP_DATA to multiline string (one char for each cell)
	OR
	pass it instead of map_size parameter.
	Dedent is performed automatically.
	Set char to '@' to indicate start pos.
	Set char to '>' to indicate exit pos.
	Set field .ENTER_TERRAIN and/or .EXIT_TERRAIN to use as terrain for those cells.
	Default is '.' for both.
	"""
	ENTER_TERRAIN = '.'
	EXIT_TERRAIN = '.'
	def __init__(self, rng, map_size):
		if hasattr(self, 'MAP_DATA'):
			self._map_data = self.MAP_DATA
		elif isinstance(map_size, str):
			self._map_data = map_size
		self._map_data = textwrap.dedent(self._map_data).splitlines()
		map_size = Size(len(self._map_data[0]), len(self._map_data))
		super(CustomMap, self).__init__(rng, map_size)
	def fill_grid(self, grid):
		for x in range(self.size.width):
			for y in range(self.size.height):
				if self._map_data[y][x] == '@':
					grid.set_cell((x, y), self.ENTER_TERRAIN)
				elif self._map_data[y][x] == '>':
					grid.set_cell((x, y), self.EXIT_TERRAIN)
				else:
					grid.set_cell((x, y), self._map_data[y][x])
	def generate_appliances(self):
		for x in range(self.size.width):
			for y in range(self.size.height):
				if self._map_data[y][x] == '@':
					yield Point(x, y), 'start'
				elif self._map_data[y][x] == '>':
					yield Point(x, y), 'exit', 0 # TODO proper next_level_id

class RogueDungeon(builders.Builder):
	""" Original Rogue dungeon.
	3x3 rooms connected by rectangular tunnels.
	"""
	def fill_grid(self, grid):
		builder = clckwrkbdgr.pcg.rogue.Dungeon(self.rng, self.size, Size(3, 3), Size(4, 4))
		builder.generate_rooms()
		builder.generate_maze()
		builder.generate_tunnels()
		grid.clear('void')

		for room in builder.iter_rooms():
			grid.set_cell((room.topleft.x, room.topleft.y), 'corner')
			grid.set_cell((room.topleft.x, room.topleft.y+room.size.height), 'corner')
			grid.set_cell((room.topleft.x+room.size.width, room.topleft.y), 'corner')
			grid.set_cell((room.topleft.x+room.size.width, room.topleft.y+room.size.height), 'corner')
			for x in range(room.topleft.x+1, room.topleft.x+room.size.width):
				grid.set_cell((x, room.topleft.y), 'wall_h')
				grid.set_cell((x, room.topleft.y+room.size.height), 'wall_h')
			for y in range(room.topleft.y+1, room.topleft.y+room.size.height):
				grid.set_cell((room.topleft.x, y), 'wall_v')
				grid.set_cell((room.topleft.x+room.size.width, y), 'wall_v')
			for y in range(room.topleft.y+1, room.topleft.y+room.size.height):
				for x in range(room.topleft.x+1, room.topleft.x+room.size.width):
					grid.set_cell((x, y), 'floor')

		for tunnel in builder.iter_tunnels():
			for cell in tunnel.iter_points():
				grid.set_cell(cell, 'rogue_passage')
			grid.set_cell(tunnel.start, 'rogue_door')
			grid.set_cell(tunnel.stop, 'rogue_door')
		self.dungeon = builder
	def generate_appliances(self):
		enter_room_key = self.rng.choice(list(self.dungeon.grid.size.iter_points()))
		enter_room = self.dungeon.grid.cell(enter_room_key)
		start_pos = self.point_in_rect(enter_room)
		yield start_pos, 'start'

		for _ in range(9):
			exit_room_key = self.rng.choice(list(self.dungeon.grid.size.iter_points()))
			exit_room = self.dungeon.grid.cell(exit_room_key)
			if exit_room_key == enter_room_key:
				continue
		exit_pos = self.point_in_rect(exit_room)
		yield exit_pos, 'exit', 0 # TODO proper next_level_id
		Log.debug("Generated exit pos: {0}".format(exit_pos))

class BSPBuilder(object):
	""" Fills specified field with binary space partition.
	"""
	def __init__(self, field, free=False, obstacle=True, door=False):
		""" Accepts three callables that should return ID of a corresponding terrain:
		- free cell (floor)
		- obstacle (wall)
		- door (or doorway)
		"""
		self.field = field
		self.free, self.obstacle, self.door = free, obstacle, door
	def fill(self, topleft, bottomright, is_horizontal, door_pos):
		""" Uses tuples generated by BinarySpacePartition.
		Draws a line with a 'door', overwrites all cell contents for specified rectangle.
		"""
		for x in range(topleft.x, bottomright.x + 1):
			for y in range(topleft.y, bottomright.y + 1):
				self.field.set_cell((x, y), self.free())
		if is_horizontal:
			the_divide = door_pos.x
			for y in range(topleft.y, bottomright.y + 1):
				self.field.set_cell((the_divide, y), self.obstacle())
		else:
			the_divide = door_pos.y
			for x in range(topleft.x, bottomright.x + 1):
				self.field.set_cell((x, the_divide), self.obstacle())
		self.field.set_cell(door_pos, self.door())

class BSPBuildingBuilder(BSPBuilder):
	""" Like BSPBuilder, but produces solid "buildings" made of "obstacle" terrain
	instead of rooms, and uses "free" terrain to crease "roads" between buildings
	instead of walls.
	"""
	def fill(self, topleft, bottomright, is_horizontal, door_pos):
		""" Uses tuples generated by BinarySpacePartition.
		Generated buildings are 1 cell narrower in every direction
		to give space for roads, which take +1 width in both direction correspondingly, resulting in width of 3 cells.
		"""
		for x in range(topleft.x + 3, bottomright.x + 1 - 3):
			for y in range(topleft.y + 3, bottomright.y + 1 - 3):
				self.field.set_cell((x, y), self.obstacle())
		if is_horizontal:
			the_divide = door_pos.x
			for y in range(topleft.y, bottomright.y + 1):
				self.field.set_cell((the_divide - 1, y), self.free())
				self.field.set_cell((the_divide, y), self.free())
				self.field.set_cell((the_divide + 1, y), self.free())
		else:
			the_divide = door_pos.y
			for x in range(topleft.x, bottomright.x + 1):
				self.field.set_cell((x, the_divide - 1), self.free())
				self.field.set_cell((x, the_divide), self.free())
				self.field.set_cell((x, the_divide + 1), self.free())
		self.field.set_cell(door_pos, self.door())

class BSPDungeon(builders.Builder):
	""" Builds closed set of rooms/galleries/quarters
	packed into large rectangular space.
	"""
	def fill_grid(self, grid):
		Log.debug("Building surrounding walls.")
		for x in range(self.size.width):
			grid.set_cell((x, 0), 'wall')
			grid.set_cell((x, self.size.height - 1), 'wall')
		for y in range(self.size.height):
			grid.set_cell((0, y), 'wall')
			grid.set_cell((self.size.width - 1, y), 'wall')

		Log.debug("Running BSP...")
		partition = bsp.BinarySpacePartition(self.rng)
		builder = BSPBuilder(grid,
								 free=lambda: 'floor',
								 obstacle=lambda: 'wall',
								 door=lambda: 'floor',
						 )
		for splitter in partition.generate(Point(1, 1), Point(self.size.width - 2, self.size.height - 2)):
			Log.debug("Splitter: {0}".format(splitter))
			builder.fill(*splitter)
	def is_open(self, pos):
		return self.grid.cell(pos) == 'floor'
	def generate_appliances(self):
		yield self.point(self.is_accessible), 'start'
		yield self.point(self.is_accessible), 'exit', 0 # TODO proper next_level_id

class CityBuilder(builders.Builder):
	""" A city block of buildings, surrounded by a thick wall.
	"""
	def fill_grid(self, grid):
		Log.debug("Building surrounding walls.")
		for x in range(self.size.width):
			grid.set_cell((x, 0), 'wall')
			grid.set_cell((x, self.size.height - 1), 'wall')
		for y in range(self.size.height):
			grid.set_cell((0, y), 'wall')
			grid.set_cell((self.size.width - 1, y), 'wall')
		for x in range(1, self.size.width - 1):
			for y in range(1, self.size.height - 1):
				grid.set_cell((x, y), 'floor')

		Log.debug("Running BSP...")
		partition = bsp.BinarySpacePartition(self.rng, min_width=8, min_height=7)
		partition.set_unfit_both_dimensions(True)
		builder = BSPBuildingBuilder(grid,
								 free=lambda: 'floor',
								 obstacle=lambda: 'wall',
								 door=lambda: 'floor',
						 )
		for splitter in partition.generate(Point(1, 1), Point(self.size.width - 2, self.size.height - 2)):
			Log.debug("Splitter: {0}".format(splitter))
			builder.fill(*splitter)
	def is_open(self, pos):
		return self.grid.cell(pos) == 'floor'
	def generate_appliances(self):
		yield self.point(self.is_accessible), 'start'
		yield self.point(self.is_accessible), 'exit', 0 # TODO proper next_level_id

class CaveBuilder(builders.Builder):
	""" A large open natural cave.
	"""
	def fill_grid(self, grid):
		cave = clckwrkbdgr.pcg.cellular.cave(self.rng, self.size)
		for pos in cave.size.iter_points():
			if cave.cell(pos):
				grid.set_cell(pos, 'floor')
			else:
				grid.set_cell(pos, 'wall')
	def is_open(self, pos):
		return self.grid.cell(pos) == 'floor'
	def generate_appliances(self):
		yield self.point(self.is_accessible), 'start'
		yield self.point(self.is_accessible), 'exit', 0 # TODO proper next_level_id

class MazeBuilder(builders.Builder):
	""" A maze labyrinth on a grid.
	Size of the grid cell is controlled by the field CELL_SIZE, default is 1 cell.
	"""
	CELL_SIZE = Size(1, 1)
	def _fill_maze(self, grid, layout, floor_terrain='tunnel_floor'):
		""" Fills actual map with terrain IDs according to given layout
		and considering cell_size.
		"""
		grid.clear('wall')
		for pos in layout.size.iter_points():
			if layout.cell(pos):
				for x in range(self.CELL_SIZE.width):
					for y in range(self.CELL_SIZE.height):
						grid.set_cell((
								1 + pos.x * self.CELL_SIZE.width + x,
								1 + pos.y * self.CELL_SIZE.height + y,
								), floor_terrain,
								)
	def is_open(self, pos):
		return self.grid.cell(pos) in ['floor', 'tunnel_floor']
	def generate_appliances(self):
		""" Places other points of interests (start, exit).
		"""
		yield self.point(self.is_accessible), 'start'
		yield self.point(self.is_accessible), 'exit', 0 # TODO proper next_level_id
	def fill_grid(self, grid):
		maze = clckwrkbdgr.pcg.maze.Maze(self.rng, self.size, self.CELL_SIZE)
		layout = maze.build()
		self._fill_maze(grid, layout)

class Sewers(MazeBuilder):
	""" Sewers: labyrinth of wide tunnels with water streams.
	"""
	CELL_SIZE = Size(4, 3)
	def _fill_maze(self, grid, layout):
		""" In addition to carving tunnels
		also pours water in them, making a connected set of streams
		with floor boardwalks under walls.
		"""
		super(Sewers, self)._fill_maze(grid, layout, floor_terrain='floor')

		# Fill water streams.
		for x in range(self.size.width):
			for y in range(self.size.height):
				if grid.cell((x, y)) == 'wall':
					continue
				for n in clckwrkbdgr.math.get_neighbours(grid, (x, y), with_diagonal=True):
					if grid.cell(n) == 'wall':
						break
				else:
					grid.set_cell((x, y), 'water')
		return grid
